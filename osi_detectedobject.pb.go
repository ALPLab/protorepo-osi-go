// Code generated by protoc-gen-go. DO NOT EDIT.
// source: osi_detectedobject.proto

package osi3

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Definition of measurement states.
//
type DetectedItemHeader_MeasurementState int32

const (
	// Measurement state is unknown (must not be used in ground truth).
	//
	DetectedItemHeader_MEASUREMENT_STATE_UNKNOWN DetectedItemHeader_MeasurementState = 0
	// Measurement state is unspecified (but known, i.e. value is not part
	// of this enum list).
	//
	DetectedItemHeader_MEASUREMENT_STATE_OTHER DetectedItemHeader_MeasurementState = 1
	// Entity has been measured by the sensor in the current timestep.
	//
	DetectedItemHeader_MEASUREMENT_STATE_MEASURED DetectedItemHeader_MeasurementState = 2
	// Entity has not been measured by the sensor in the current timestep.
	// Values provided by tracking only.
	//
	DetectedItemHeader_MEASUREMENT_STATE_PREDICTED DetectedItemHeader_MeasurementState = 3
)

var DetectedItemHeader_MeasurementState_name = map[int32]string{
	0: "MEASUREMENT_STATE_UNKNOWN",
	1: "MEASUREMENT_STATE_OTHER",
	2: "MEASUREMENT_STATE_MEASURED",
	3: "MEASUREMENT_STATE_PREDICTED",
}

var DetectedItemHeader_MeasurementState_value = map[string]int32{
	"MEASUREMENT_STATE_UNKNOWN":   0,
	"MEASUREMENT_STATE_OTHER":     1,
	"MEASUREMENT_STATE_MEASURED":  2,
	"MEASUREMENT_STATE_PREDICTED": 3,
}

func (x DetectedItemHeader_MeasurementState) String() string {
	return proto.EnumName(DetectedItemHeader_MeasurementState_name, int32(x))
}

func (DetectedItemHeader_MeasurementState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{0, 0}
}

// Definition of available reference points. Left/middle/right and
// front/middle/rear indicate the position in y- and x-direction
// respectively. The z position is always considered as middle.
//
type DetectedMovingObject_ReferencePoint int32

const (
	// Reference point is unknown, i.e. sensor does not report a reference
	// point for the position coordinate.
	// Value must not be used in ground truth data.
	// Usually this means that the reference point for the given position
	// coordinates is a largely arbitrary point within the bounding volume
	// unknown to the sensor. If this value is set, the center of the
	// bounding box should be used as reference point by convention, unless
	// the specific use case requires otherwise.
	//
	DetectedMovingObject_REFERENCE_POINT_UNKNOWN DetectedMovingObject_ReferencePoint = 0
	// Other (unspecified but known) reference point.
	//
	DetectedMovingObject_REFERENCE_POINT_OTHER DetectedMovingObject_ReferencePoint = 1
	// Center of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_CENTER DetectedMovingObject_ReferencePoint = 2
	// Middle-Left of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_MIDDLE_LEFT DetectedMovingObject_ReferencePoint = 3
	// Middle-Right of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_MIDDLE_RIGHT DetectedMovingObject_ReferencePoint = 4
	// Rear-Middle of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_REAR_MIDDLE DetectedMovingObject_ReferencePoint = 5
	// Rear-Left of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_REAR_LEFT DetectedMovingObject_ReferencePoint = 6
	// Rear-Right of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_REAR_RIGHT DetectedMovingObject_ReferencePoint = 7
	// Front-Middle of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_FRONT_MIDDLE DetectedMovingObject_ReferencePoint = 8
	// Front-Left of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_FRONT_LEFT DetectedMovingObject_ReferencePoint = 9
	// Front-Right of the bounding box.
	//
	DetectedMovingObject_REFERENCE_POINT_FRONT_RIGHT DetectedMovingObject_ReferencePoint = 10
)

var DetectedMovingObject_ReferencePoint_name = map[int32]string{
	0:  "REFERENCE_POINT_UNKNOWN",
	1:  "REFERENCE_POINT_OTHER",
	2:  "REFERENCE_POINT_CENTER",
	3:  "REFERENCE_POINT_MIDDLE_LEFT",
	4:  "REFERENCE_POINT_MIDDLE_RIGHT",
	5:  "REFERENCE_POINT_REAR_MIDDLE",
	6:  "REFERENCE_POINT_REAR_LEFT",
	7:  "REFERENCE_POINT_REAR_RIGHT",
	8:  "REFERENCE_POINT_FRONT_MIDDLE",
	9:  "REFERENCE_POINT_FRONT_LEFT",
	10: "REFERENCE_POINT_FRONT_RIGHT",
}

var DetectedMovingObject_ReferencePoint_value = map[string]int32{
	"REFERENCE_POINT_UNKNOWN":      0,
	"REFERENCE_POINT_OTHER":        1,
	"REFERENCE_POINT_CENTER":       2,
	"REFERENCE_POINT_MIDDLE_LEFT":  3,
	"REFERENCE_POINT_MIDDLE_RIGHT": 4,
	"REFERENCE_POINT_REAR_MIDDLE":  5,
	"REFERENCE_POINT_REAR_LEFT":    6,
	"REFERENCE_POINT_REAR_RIGHT":   7,
	"REFERENCE_POINT_FRONT_MIDDLE": 8,
	"REFERENCE_POINT_FRONT_LEFT":   9,
	"REFERENCE_POINT_FRONT_RIGHT":  10,
}

func (x DetectedMovingObject_ReferencePoint) String() string {
	return proto.EnumName(DetectedMovingObject_ReferencePoint_name, int32(x))
}

func (DetectedMovingObject_ReferencePoint) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{2, 0}
}

// Information about a possible movement of the object during tracking.
//
type DetectedMovingObject_MovementState int32

const (
	// Movement state is unknown.
	//
	DetectedMovingObject_MOVEMENT_STATE_UNKNOWN DetectedMovingObject_MovementState = 0
	// Other (unspecified but known).
	//
	DetectedMovingObject_MOVEMENT_STATE_OTHER DetectedMovingObject_MovementState = 1
	// Until now no object movement was detected in tracking history.
	//
	DetectedMovingObject_MOVEMENT_STATE_STATIONARY DetectedMovingObject_MovementState = 2
	// Object moves currently.
	//
	DetectedMovingObject_MOVEMENT_STATE_MOVING DetectedMovingObject_MovementState = 3
	// Object movement was detected in tracking history, but object is
	// currently not moving.
	//
	DetectedMovingObject_MOVEMENT_STATE_STOPPED DetectedMovingObject_MovementState = 4
)

var DetectedMovingObject_MovementState_name = map[int32]string{
	0: "MOVEMENT_STATE_UNKNOWN",
	1: "MOVEMENT_STATE_OTHER",
	2: "MOVEMENT_STATE_STATIONARY",
	3: "MOVEMENT_STATE_MOVING",
	4: "MOVEMENT_STATE_STOPPED",
}

var DetectedMovingObject_MovementState_value = map[string]int32{
	"MOVEMENT_STATE_UNKNOWN":    0,
	"MOVEMENT_STATE_OTHER":      1,
	"MOVEMENT_STATE_STATIONARY": 2,
	"MOVEMENT_STATE_MOVING":     3,
	"MOVEMENT_STATE_STOPPED":    4,
}

func (x DetectedMovingObject_MovementState) String() string {
	return proto.EnumName(DetectedMovingObject_MovementState_name, int32(x))
}

func (DetectedMovingObject_MovementState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{2, 1}
}

//
// \brief The common information for a detected item as estimated by the
// sensor.
//
type DetectedItemHeader struct {
	// Specific ID of the detected item as assigned by the sensor internally.
	// Need not match with \c #ground_truth_id.
	//
	TrackingId *Identifier `protobuf:"bytes,1,opt,name=tracking_id,json=trackingId,proto3" json:"tracking_id,omitempty"`
	// The ID of the original detected item in the ground truth.
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	GroundTruthId []*Identifier `protobuf:"bytes,2,rep,name=ground_truth_id,json=groundTruthId,proto3" json:"ground_truth_id,omitempty"`
	// The estimated probability that this detected item really exists, not
	// based on history.
	//
	// \note Use as confidence measure where a low value means less confidence
	// and a high value indicates strong confidence.
	//
	// Range: [0,1]
	//
	ExistenceProbability float64 `protobuf:"fixed64,3,opt,name=existence_probability,json=existenceProbability,proto3" json:"existence_probability,omitempty"`
	// The amount of time that this detected object has been continuously
	// observed/tracked.
	//
	// \note: 'Time stamp' - Age := 'point in time' when the object has
	// been observed for the first time.
	//
	// Unit: [s]
	//
	Age float64 `protobuf:"fixed64,4,opt,name=age,proto3" json:"age,omitempty"`
	// The measurement state.
	//
	MeasurementState DetectedItemHeader_MeasurementState `protobuf:"varint,5,opt,name=measurement_state,json=measurementState,proto3,enum=osi3.DetectedItemHeader_MeasurementState" json:"measurement_state,omitempty"`
	// A list of physical sensors which detected this detected item.
	//
	// If \c SensorData has detected entities and all detections are missing,
	// then e.g. the number of sensors can confirm the
	// \c #existence_probability.
	//
	// \note This information can be determined via the detected entities'
	// detections ( \c ...Detection::object_id = 'this detected item' ) and
	// the sensors (their IDs) to which these detections belong.
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	SensorId             []*Identifier `protobuf:"bytes,6,rep,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *DetectedItemHeader) Reset()         { *m = DetectedItemHeader{} }
func (m *DetectedItemHeader) String() string { return proto.CompactTextString(m) }
func (*DetectedItemHeader) ProtoMessage()    {}
func (*DetectedItemHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{0}
}

func (m *DetectedItemHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectedItemHeader.Unmarshal(m, b)
}
func (m *DetectedItemHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectedItemHeader.Marshal(b, m, deterministic)
}
func (m *DetectedItemHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectedItemHeader.Merge(m, src)
}
func (m *DetectedItemHeader) XXX_Size() int {
	return xxx_messageInfo_DetectedItemHeader.Size(m)
}
func (m *DetectedItemHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectedItemHeader.DiscardUnknown(m)
}

var xxx_messageInfo_DetectedItemHeader proto.InternalMessageInfo

func (m *DetectedItemHeader) GetTrackingId() *Identifier {
	if m != nil {
		return m.TrackingId
	}
	return nil
}

func (m *DetectedItemHeader) GetGroundTruthId() []*Identifier {
	if m != nil {
		return m.GroundTruthId
	}
	return nil
}

func (m *DetectedItemHeader) GetExistenceProbability() float64 {
	if m != nil {
		return m.ExistenceProbability
	}
	return 0
}

func (m *DetectedItemHeader) GetAge() float64 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *DetectedItemHeader) GetMeasurementState() DetectedItemHeader_MeasurementState {
	if m != nil {
		return m.MeasurementState
	}
	return DetectedItemHeader_MEASUREMENT_STATE_UNKNOWN
}

func (m *DetectedItemHeader) GetSensorId() []*Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

//
// \brief A stationary object (e.g. landmark) in the environment as detected by
// the sensor.
//
// \image html OSI_DetectedStatObject.jpg
//
type DetectedStationaryObject struct {
	// Common information of one detected item.
	//
	Header *DetectedItemHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// The base parameters of the stationary object.
	//
	Base *BaseStationary `protobuf:"bytes,2,opt,name=base,proto3" json:"base,omitempty"`
	// The root mean squared error of the base parameters of the detected
	// stationary object (e.g. landmark). \c StationaryObject::base has to be
	// identical for all \c #candidate stationary objects.
	//
	BaseRmse *BaseStationary `protobuf:"bytes,3,opt,name=base_rmse,json=baseRmse,proto3" json:"base_rmse,omitempty"`
	// A list of candidates for this stationary object as estimated by the
	// sensor.
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	Candidate            []*DetectedStationaryObject_CandidateStationaryObject `protobuf:"bytes,4,rep,name=candidate,proto3" json:"candidate,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *DetectedStationaryObject) Reset()         { *m = DetectedStationaryObject{} }
func (m *DetectedStationaryObject) String() string { return proto.CompactTextString(m) }
func (*DetectedStationaryObject) ProtoMessage()    {}
func (*DetectedStationaryObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{1}
}

func (m *DetectedStationaryObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectedStationaryObject.Unmarshal(m, b)
}
func (m *DetectedStationaryObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectedStationaryObject.Marshal(b, m, deterministic)
}
func (m *DetectedStationaryObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectedStationaryObject.Merge(m, src)
}
func (m *DetectedStationaryObject) XXX_Size() int {
	return xxx_messageInfo_DetectedStationaryObject.Size(m)
}
func (m *DetectedStationaryObject) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectedStationaryObject.DiscardUnknown(m)
}

var xxx_messageInfo_DetectedStationaryObject proto.InternalMessageInfo

func (m *DetectedStationaryObject) GetHeader() *DetectedItemHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DetectedStationaryObject) GetBase() *BaseStationary {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *DetectedStationaryObject) GetBaseRmse() *BaseStationary {
	if m != nil {
		return m.BaseRmse
	}
	return nil
}

func (m *DetectedStationaryObject) GetCandidate() []*DetectedStationaryObject_CandidateStationaryObject {
	if m != nil {
		return m.Candidate
	}
	return nil
}

//
// \brief A candidate for a detected stationary object as estimated
// by the sensor.
//
type DetectedStationaryObject_CandidateStationaryObject struct {
	// The estimated probability that this candidate is the true value.
	//
	// \note The sum of all \c #probability must be one. This probability is
	// given under the condition of
	// \c DetectedItemHeader::existence_probability.
	//
	// Range: [0,1]
	//
	Probability float64 `protobuf:"fixed64,1,opt,name=probability,proto3" json:"probability,omitempty"`
	// The classification of the stationary object (e.g. landmark).
	//
	Classification       *StationaryObject_Classification `protobuf:"bytes,2,opt,name=classification,proto3" json:"classification,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DetectedStationaryObject_CandidateStationaryObject) Reset() {
	*m = DetectedStationaryObject_CandidateStationaryObject{}
}
func (m *DetectedStationaryObject_CandidateStationaryObject) String() string {
	return proto.CompactTextString(m)
}
func (*DetectedStationaryObject_CandidateStationaryObject) ProtoMessage() {}
func (*DetectedStationaryObject_CandidateStationaryObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{1, 0}
}

func (m *DetectedStationaryObject_CandidateStationaryObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectedStationaryObject_CandidateStationaryObject.Unmarshal(m, b)
}
func (m *DetectedStationaryObject_CandidateStationaryObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectedStationaryObject_CandidateStationaryObject.Marshal(b, m, deterministic)
}
func (m *DetectedStationaryObject_CandidateStationaryObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectedStationaryObject_CandidateStationaryObject.Merge(m, src)
}
func (m *DetectedStationaryObject_CandidateStationaryObject) XXX_Size() int {
	return xxx_messageInfo_DetectedStationaryObject_CandidateStationaryObject.Size(m)
}
func (m *DetectedStationaryObject_CandidateStationaryObject) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectedStationaryObject_CandidateStationaryObject.DiscardUnknown(m)
}

var xxx_messageInfo_DetectedStationaryObject_CandidateStationaryObject proto.InternalMessageInfo

func (m *DetectedStationaryObject_CandidateStationaryObject) GetProbability() float64 {
	if m != nil {
		return m.Probability
	}
	return 0
}

func (m *DetectedStationaryObject_CandidateStationaryObject) GetClassification() *StationaryObject_Classification {
	if m != nil {
		return m.Classification
	}
	return nil
}

//
// \brief Moving object in the environment as detected and perceived by
// the sensor.
//
type DetectedMovingObject struct {
	// Common information of one detected item.
	//
	Header *DetectedItemHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// The base parameters of the moving object.
	//
	// \note The bounding box does NOT includes mirrors for vehicles.
	// \note The parent frame of \c base is the sensor's vehicle frame.
	//
	Base *BaseMoving `protobuf:"bytes,2,opt,name=base,proto3" json:"base,omitempty"`
	// The root mean squared error of the base parameters of the detected
	// moving object (e.g. car). \c MovingObject::base has to be
	// identical for all \c #candidate moving objects.
	//
	// \note The parent frame of \c base is the sensor's vehicle frame.
	//
	BaseRmse *BaseMoving `protobuf:"bytes,3,opt,name=base_rmse,json=baseRmse,proto3" json:"base_rmse,omitempty"`
	// Reference point location specification of the sensor measurement
	// (required to decouple sensor measurement, position and bounding box
	// estimation) as used by the sensor (model).
	//
	// \note Note that the value of this field has no impact on the value of
	// object::position, which always references the center of the object /
	// bounding box.
	//
	ReferencePoint DetectedMovingObject_ReferencePoint `protobuf:"varint,4,opt,name=reference_point,json=referencePoint,proto3,enum=osi3.DetectedMovingObject_ReferencePoint" json:"reference_point,omitempty"`
	// Actual movement state w.r.t. the moving object history.
	//
	MovementState DetectedMovingObject_MovementState `protobuf:"varint,5,opt,name=movement_state,json=movementState,proto3,enum=osi3.DetectedMovingObject_MovementState" json:"movement_state,omitempty"`
	// Percentage side lane left.
	//
	// Percentage value of the object width in the corresponding lane.
	//
	PercentageSideLaneLeft float64 `protobuf:"fixed64,6,opt,name=percentage_side_lane_left,json=percentageSideLaneLeft,proto3" json:"percentage_side_lane_left,omitempty"`
	// Percentage side lane right.
	//
	// Percentage value of the object width in the corresponding lane.
	//
	PercentageSideLaneRight float64 `protobuf:"fixed64,7,opt,name=percentage_side_lane_right,json=percentageSideLaneRight,proto3" json:"percentage_side_lane_right,omitempty"`
	// A list of candidates for this moving object as estimated by the
	// sensor (e.g. pedestrian, car).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	Candidate []*DetectedMovingObject_CandidateMovingObject `protobuf:"bytes,8,rep,name=candidate,proto3" json:"candidate,omitempty"`
	// Additional data that is specific to radar sensors.
	//
	// \note Field need not be set if simulated sensor is not a radar
	// sensor.
	//
	RadarSpecifics *RadarSpecificObjectData `protobuf:"bytes,100,opt,name=radar_specifics,json=radarSpecifics,proto3" json:"radar_specifics,omitempty"`
	// Additional data that is specific to lidar sensors.
	//
	// \note Field need not be set if simulated sensor is not a lidar
	// sensor.
	//
	LidarSpecifics *LidarSpecificObjectData `protobuf:"bytes,101,opt,name=lidar_specifics,json=lidarSpecifics,proto3" json:"lidar_specifics,omitempty"`
	// Additional data that is specific to camera sensors.
	//
	// \note Field need not be set if simulated sensor is not a camera
	// sensor.
	//
	CameraSpecifics *CameraSpecificObjectData `protobuf:"bytes,102,opt,name=camera_specifics,json=cameraSpecifics,proto3" json:"camera_specifics,omitempty"`
	// Additional data that is specific to ultrasonic sensors.
	//
	// \note Field need not be set if simulated sensor is not an ultrasonic
	// sensor.
	//
	UltrasonicSpecifics  *UltrasonicSpecificObjectData `protobuf:"bytes,103,opt,name=ultrasonic_specifics,json=ultrasonicSpecifics,proto3" json:"ultrasonic_specifics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *DetectedMovingObject) Reset()         { *m = DetectedMovingObject{} }
func (m *DetectedMovingObject) String() string { return proto.CompactTextString(m) }
func (*DetectedMovingObject) ProtoMessage()    {}
func (*DetectedMovingObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{2}
}

func (m *DetectedMovingObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectedMovingObject.Unmarshal(m, b)
}
func (m *DetectedMovingObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectedMovingObject.Marshal(b, m, deterministic)
}
func (m *DetectedMovingObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectedMovingObject.Merge(m, src)
}
func (m *DetectedMovingObject) XXX_Size() int {
	return xxx_messageInfo_DetectedMovingObject.Size(m)
}
func (m *DetectedMovingObject) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectedMovingObject.DiscardUnknown(m)
}

var xxx_messageInfo_DetectedMovingObject proto.InternalMessageInfo

func (m *DetectedMovingObject) GetHeader() *DetectedItemHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *DetectedMovingObject) GetBase() *BaseMoving {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *DetectedMovingObject) GetBaseRmse() *BaseMoving {
	if m != nil {
		return m.BaseRmse
	}
	return nil
}

func (m *DetectedMovingObject) GetReferencePoint() DetectedMovingObject_ReferencePoint {
	if m != nil {
		return m.ReferencePoint
	}
	return DetectedMovingObject_REFERENCE_POINT_UNKNOWN
}

func (m *DetectedMovingObject) GetMovementState() DetectedMovingObject_MovementState {
	if m != nil {
		return m.MovementState
	}
	return DetectedMovingObject_MOVEMENT_STATE_UNKNOWN
}

func (m *DetectedMovingObject) GetPercentageSideLaneLeft() float64 {
	if m != nil {
		return m.PercentageSideLaneLeft
	}
	return 0
}

func (m *DetectedMovingObject) GetPercentageSideLaneRight() float64 {
	if m != nil {
		return m.PercentageSideLaneRight
	}
	return 0
}

func (m *DetectedMovingObject) GetCandidate() []*DetectedMovingObject_CandidateMovingObject {
	if m != nil {
		return m.Candidate
	}
	return nil
}

func (m *DetectedMovingObject) GetRadarSpecifics() *RadarSpecificObjectData {
	if m != nil {
		return m.RadarSpecifics
	}
	return nil
}

func (m *DetectedMovingObject) GetLidarSpecifics() *LidarSpecificObjectData {
	if m != nil {
		return m.LidarSpecifics
	}
	return nil
}

func (m *DetectedMovingObject) GetCameraSpecifics() *CameraSpecificObjectData {
	if m != nil {
		return m.CameraSpecifics
	}
	return nil
}

func (m *DetectedMovingObject) GetUltrasonicSpecifics() *UltrasonicSpecificObjectData {
	if m != nil {
		return m.UltrasonicSpecifics
	}
	return nil
}

//
// \brief A candidate for a detected moving object as estimated by the
// sensor.
//
type DetectedMovingObject_CandidateMovingObject struct {
	// The estimated probability that this candidate is the true value.
	//
	// \note The sum of all \c #probability must be one. This probability is
	// given under the condition of
	// \c DetectedItemHeader::existence_probability.
	//
	// Range: [0,1]
	//
	Probability float64 `protobuf:"fixed64,1,opt,name=probability,proto3" json:"probability,omitempty"`
	// The description of the moving object (e.g. car).
	//
	Type MovingObject_Type `protobuf:"varint,2,opt,name=type,proto3,enum=osi3.MovingObject_Type" json:"type,omitempty"`
	// Specific information about the classification of the vehicle.
	//
	//
	// \note This field is mandatory if the \c CandidateMovingObject::type
	// is \c MovingObject::TYPE_VEHICLE .
	//
	VehicleClassification *MovingObject_VehicleClassification `protobuf:"bytes,3,opt,name=vehicle_classification,json=vehicleClassification,proto3" json:"vehicle_classification,omitempty"`
	// Pedestrian head pose for behavior prediction. Describes the head
	// orientation w.r.t. the host vehicle orientation.
	// The x-axis of the right-handed head frame is pointing along the
	// pedestrian's straight ahead viewing direction and the z-axis is
	// pointing upwards (cranial direction [1] i.e. to pedestrian's skull
	// cap).
	//
	// <tt>View_normal_base_coord_system =
	// Inverse_Rotation(#head_pose)*Unit_vector_x</tt>
	//
	// \note This field is mandatory if the \c CandidateMovingObject.type is
	// \c MovingObject::TYPE_PEDESTRIAN
	//
	// \par References:
	// - [1] https://en.wikipedia.org/wiki/Anatomical_terms_of_location
	//
	HeadPose *Orientation3D `protobuf:"bytes,4,opt,name=head_pose,json=headPose,proto3" json:"head_pose,omitempty"`
	// Pedestrian upper body pose for behavior prediction. Describes the
	// upper body orientation w.r.t. the host vehicle orientation.
	// The x-axis of the right-handed upper body frame is pointing along the
	// pedestrian's upper body ventral direction [2] (i.e. usually
	// pedestrian's intended moving direction) and the z-axis is pointing
	// upwards (to pedestrian's head).
	//
	// <tt>View_normal_base_coord_system =
	// Inverse_Rotation(#upper_body_pose)*Unit_vector_x</tt>
	//
	// \note This field is mandatory if the \c CandidateMovingObject::type
	// is \c MovingObject::TYPE_PEDESTRIAN
	//
	// \par References:
	// - [2] https://en.wikipedia.org/wiki/Anatomical_terms_of_location
	//
	UpperBodyPose        *Orientation3D `protobuf:"bytes,5,opt,name=upper_body_pose,json=upperBodyPose,proto3" json:"upper_body_pose,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DetectedMovingObject_CandidateMovingObject) Reset() {
	*m = DetectedMovingObject_CandidateMovingObject{}
}
func (m *DetectedMovingObject_CandidateMovingObject) String() string {
	return proto.CompactTextString(m)
}
func (*DetectedMovingObject_CandidateMovingObject) ProtoMessage() {}
func (*DetectedMovingObject_CandidateMovingObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_25bb2a8ea5a627fb, []int{2, 0}
}

func (m *DetectedMovingObject_CandidateMovingObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DetectedMovingObject_CandidateMovingObject.Unmarshal(m, b)
}
func (m *DetectedMovingObject_CandidateMovingObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DetectedMovingObject_CandidateMovingObject.Marshal(b, m, deterministic)
}
func (m *DetectedMovingObject_CandidateMovingObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DetectedMovingObject_CandidateMovingObject.Merge(m, src)
}
func (m *DetectedMovingObject_CandidateMovingObject) XXX_Size() int {
	return xxx_messageInfo_DetectedMovingObject_CandidateMovingObject.Size(m)
}
func (m *DetectedMovingObject_CandidateMovingObject) XXX_DiscardUnknown() {
	xxx_messageInfo_DetectedMovingObject_CandidateMovingObject.DiscardUnknown(m)
}

var xxx_messageInfo_DetectedMovingObject_CandidateMovingObject proto.InternalMessageInfo

func (m *DetectedMovingObject_CandidateMovingObject) GetProbability() float64 {
	if m != nil {
		return m.Probability
	}
	return 0
}

func (m *DetectedMovingObject_CandidateMovingObject) GetType() MovingObject_Type {
	if m != nil {
		return m.Type
	}
	return MovingObject_TYPE_UNKNOWN
}

func (m *DetectedMovingObject_CandidateMovingObject) GetVehicleClassification() *MovingObject_VehicleClassification {
	if m != nil {
		return m.VehicleClassification
	}
	return nil
}

func (m *DetectedMovingObject_CandidateMovingObject) GetHeadPose() *Orientation3D {
	if m != nil {
		return m.HeadPose
	}
	return nil
}

func (m *DetectedMovingObject_CandidateMovingObject) GetUpperBodyPose() *Orientation3D {
	if m != nil {
		return m.UpperBodyPose
	}
	return nil
}

func init() {
	proto.RegisterEnum("osi3.DetectedItemHeader_MeasurementState", DetectedItemHeader_MeasurementState_name, DetectedItemHeader_MeasurementState_value)
	proto.RegisterEnum("osi3.DetectedMovingObject_ReferencePoint", DetectedMovingObject_ReferencePoint_name, DetectedMovingObject_ReferencePoint_value)
	proto.RegisterEnum("osi3.DetectedMovingObject_MovementState", DetectedMovingObject_MovementState_name, DetectedMovingObject_MovementState_value)
	proto.RegisterType((*DetectedItemHeader)(nil), "osi3.DetectedItemHeader")
	proto.RegisterType((*DetectedStationaryObject)(nil), "osi3.DetectedStationaryObject")
	proto.RegisterType((*DetectedStationaryObject_CandidateStationaryObject)(nil), "osi3.DetectedStationaryObject.CandidateStationaryObject")
	proto.RegisterType((*DetectedMovingObject)(nil), "osi3.DetectedMovingObject")
	proto.RegisterType((*DetectedMovingObject_CandidateMovingObject)(nil), "osi3.DetectedMovingObject.CandidateMovingObject")
}

func init() { proto.RegisterFile("osi_detectedobject.proto", fileDescriptor_25bb2a8ea5a627fb) }

var fileDescriptor_25bb2a8ea5a627fb = []byte{
	// 1034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x6e, 0xdb, 0x36,
	0x1c, 0x9f, 0x6c, 0x27, 0x4d, 0x18, 0xc4, 0xd1, 0xd8, 0x7c, 0x28, 0xee, 0xda, 0x19, 0xc6, 0x06,
	0x78, 0x18, 0x6a, 0xa4, 0xc9, 0xa5, 0x43, 0x4f, 0x49, 0xac, 0x34, 0xc2, 0x62, 0xcb, 0xa0, 0x95,
	0x0c, 0x3b, 0x09, 0xb4, 0x44, 0x3b, 0xdc, 0x2c, 0xc9, 0x20, 0xe9, 0x60, 0xbe, 0xed, 0x01, 0x06,
	0x6c, 0xf7, 0xbd, 0xc7, 0xde, 0x67, 0xd7, 0x3d, 0xc5, 0x40, 0xd2, 0x8e, 0xf5, 0xe5, 0x62, 0xd8,
	0x25, 0xb1, 0xf8, 0xfb, 0xe0, 0x9f, 0xff, 0x0f, 0x51, 0xc0, 0x4a, 0x38, 0xf5, 0x43, 0x22, 0x48,
	0x20, 0x48, 0x98, 0x8c, 0x7e, 0x22, 0x81, 0xe8, 0xcc, 0x58, 0x22, 0x12, 0x58, 0x4b, 0x38, 0xbd,
	0x68, 0x98, 0x12, 0x0f, 0x92, 0x28, 0x4a, 0x62, 0xbd, 0xae, 0x57, 0xd2, 0xcc, 0x86, 0xf2, 0xe0,
	0x24, 0xe6, 0x09, 0xe3, 0x33, 0x12, 0xd0, 0x31, 0x0d, 0x34, 0xd2, 0xfa, 0xbb, 0x0a, 0x60, 0x77,
	0x69, 0xee, 0x08, 0x12, 0xdd, 0x12, 0x1c, 0x12, 0x06, 0xdf, 0x81, 0x3d, 0xc1, 0x70, 0xf0, 0x33,
	0x8d, 0x27, 0x3e, 0x0d, 0x2d, 0xa3, 0x69, 0xb4, 0xf7, 0xce, 0xcd, 0x8e, 0xdc, 0xb0, 0xe3, 0x84,
	0x24, 0x16, 0x74, 0x4c, 0x09, 0x43, 0x60, 0x45, 0x72, 0x42, 0xf8, 0x1e, 0x1c, 0x4c, 0x58, 0x32,
	0x8f, 0x43, 0x5f, 0xb0, 0xb9, 0x78, 0x94, 0xb2, 0x4a, 0xb3, 0x5a, 0x2a, 0xdb, 0xd7, 0x44, 0x4f,
	0xf2, 0x9c, 0x10, 0x5e, 0x80, 0x23, 0xf2, 0x0b, 0xe5, 0x82, 0xc4, 0x01, 0xf1, 0x67, 0x2c, 0x19,
	0xe1, 0x11, 0x9d, 0x52, 0xb1, 0xb0, 0xaa, 0x4d, 0xa3, 0x6d, 0xa0, 0xc3, 0x67, 0x70, 0xb0, 0xc6,
	0xa0, 0x09, 0xaa, 0x78, 0x42, 0xac, 0x9a, 0xa2, 0xc8, 0x9f, 0xf0, 0x01, 0x7c, 0x1e, 0x11, 0xcc,
	0xe7, 0x8c, 0x44, 0x24, 0x16, 0x3e, 0x17, 0x58, 0x10, 0x6b, 0xab, 0x69, 0xb4, 0xeb, 0xe7, 0xdf,
	0xe8, 0x10, 0x8a, 0x07, 0xed, 0xf4, 0xd6, 0x8a, 0xa1, 0x14, 0x20, 0x33, 0xca, 0xad, 0xc0, 0xb7,
	0x60, 0x57, 0xa7, 0x4e, 0x1e, 0x69, 0x7b, 0xc3, 0x91, 0x76, 0x34, 0xc5, 0x09, 0x5b, 0xbf, 0x1b,
	0xc0, 0xcc, 0xbb, 0xc2, 0xd7, 0xe0, 0xb4, 0x67, 0x5f, 0x0e, 0xef, 0x91, 0xdd, 0xb3, 0xfb, 0x9e,
	0x3f, 0xf4, 0x2e, 0x3d, 0xdb, 0xbf, 0xef, 0x7f, 0xdf, 0x77, 0x7f, 0xe8, 0x9b, 0x9f, 0xc1, 0x57,
	0xe0, 0xa4, 0x08, 0xbb, 0xde, 0xad, 0x8d, 0x4c, 0x03, 0xbe, 0x01, 0x8d, 0x22, 0xb8, 0x5c, 0xe9,
	0x9a, 0x15, 0xf8, 0x25, 0x78, 0x55, 0xc4, 0x07, 0xc8, 0xee, 0x3a, 0xd7, 0x9e, 0xdd, 0x35, 0xab,
	0xad, 0x3f, 0xaa, 0xc0, 0x5a, 0x1d, 0x5d, 0x86, 0x43, 0x93, 0x18, 0xb3, 0x85, 0xab, 0x1a, 0x04,
	0x9e, 0x81, 0xed, 0x47, 0x95, 0x8a, 0x65, 0x91, 0xad, 0x4d, 0xa9, 0x42, 0x4b, 0x1e, 0x6c, 0x83,
	0xda, 0x08, 0x73, 0x62, 0x55, 0x14, 0xff, 0x50, 0xf3, 0xaf, 0x30, 0x27, 0x6b, 0x6f, 0xa4, 0x18,
	0xf0, 0x1d, 0xd8, 0x95, 0xff, 0x7d, 0x16, 0x71, 0xa2, 0x8a, 0xb9, 0x89, 0xbe, 0x23, 0x69, 0x28,
	0xe2, 0xb2, 0x88, 0xbb, 0x01, 0x8e, 0x43, 0x1a, 0xca, 0xe2, 0xd5, 0x54, 0xb2, 0xdf, 0x67, 0x23,
	0xca, 0x9f, 0xa0, 0x73, 0xbd, 0xe2, 0xe7, 0x11, 0xb4, 0xb6, 0x6a, 0xfc, 0x66, 0x80, 0xd3, 0x8d,
	0x44, 0xd8, 0x04, 0x7b, 0xe9, 0xbe, 0x33, 0x54, 0x53, 0xa5, 0x97, 0x60, 0x0f, 0xd4, 0x83, 0x29,
	0xe6, 0x5c, 0x8e, 0x8e, 0x12, 0x2f, 0x8f, 0xff, 0xb5, 0x0e, 0xae, 0x18, 0x54, 0x86, 0x8c, 0x72,
	0xe2, 0xd6, 0xaf, 0xfb, 0xe0, 0x70, 0x75, 0xa0, 0x5e, 0xf2, 0x44, 0xe3, 0xc9, 0xff, 0x2e, 0xc7,
	0x57, 0x99, 0x72, 0x98, 0xeb, 0xfc, 0x6a, 0xdf, 0x65, 0x29, 0xde, 0x16, 0x4b, 0x51, 0xa4, 0xae,
	0xcb, 0x80, 0xc0, 0x01, 0x23, 0x63, 0xc2, 0xf4, 0x48, 0x26, 0x34, 0x16, 0x6a, 0xd2, 0x0a, 0x93,
	0x94, 0x8e, 0xbd, 0x83, 0x56, 0x8a, 0x81, 0x14, 0xa0, 0x3a, 0xcb, 0x3c, 0x43, 0x17, 0xd4, 0xa3,
	0xe4, 0xa9, 0x38, 0x9c, 0xed, 0x4f, 0x58, 0xf6, 0x96, 0x02, 0x3d, 0x9b, 0xfb, 0x51, 0xfa, 0x11,
	0x7e, 0x07, 0x4e, 0x67, 0x84, 0x05, 0x24, 0x16, 0x78, 0x42, 0x7c, 0x4e, 0x43, 0xe2, 0x4f, 0x71,
	0x4c, 0xfc, 0x29, 0x19, 0x0b, 0x6b, 0x5b, 0xd5, 0xf0, 0x78, 0x4d, 0x18, 0xd2, 0x90, 0xdc, 0xe1,
	0x98, 0xdc, 0x91, 0xb1, 0x80, 0x1f, 0x40, 0xa3, 0x54, 0xca, 0xe8, 0xe4, 0x51, 0x58, 0x2f, 0x94,
	0xf6, 0xa4, 0xa8, 0x45, 0x12, 0x86, 0xfd, 0x74, 0x8f, 0xee, 0xa8, 0x1e, 0x3d, 0xfb, 0xc4, 0x19,
	0x9e, 0xdb, 0x2e, 0xbd, 0x9a, 0xea, 0x4d, 0x78, 0x03, 0x0e, 0x18, 0x0e, 0x31, 0xf3, 0x57, 0xef,
	0x66, 0x6e, 0x85, 0xaa, 0x42, 0xaf, 0xb5, 0x2b, 0x92, 0xe0, 0x70, 0x89, 0x69, 0x79, 0x17, 0x0b,
	0x8c, 0xea, 0x2c, 0x0d, 0x70, 0xe9, 0x33, 0xa5, 0x59, 0x1f, 0x92, 0xf6, 0xb9, 0xa3, 0x1b, 0x7c,
	0xa6, 0x34, 0xe3, 0xe3, 0x00, 0x33, 0xc0, 0x11, 0x61, 0x38, 0x65, 0x34, 0x56, 0x46, 0x6f, 0xb4,
	0xd1, 0xb5, 0x42, 0x4b, 0x9c, 0x0e, 0x82, 0x0c, 0xc2, 0xe1, 0x3d, 0x38, 0x9c, 0x4f, 0x05, 0xc3,
	0x3c, 0x89, 0x69, 0x90, 0xb2, 0x9b, 0x28, 0xbb, 0x96, 0xb6, 0xbb, 0x7f, 0x66, 0x94, 0x58, 0xbe,
	0x9c, 0x17, 0x50, 0xde, 0xf8, 0xab, 0x02, 0x8e, 0x4a, 0xd3, 0xfa, 0x1f, 0x26, 0xf9, 0x5b, 0x50,
	0x13, 0x8b, 0x99, 0x9e, 0x97, 0xfa, 0xf9, 0x89, 0x0e, 0x21, 0x53, 0x30, 0x6f, 0x31, 0x23, 0x48,
	0x91, 0xa0, 0x0f, 0x8e, 0x9f, 0xc8, 0x23, 0x0d, 0xa6, 0xc4, 0xcf, 0x8d, 0xbf, 0x9e, 0xa1, 0x76,
	0x89, 0xfc, 0x41, 0x0b, 0x72, 0x6f, 0x80, 0xa3, 0xa7, 0xb2, 0x65, 0x78, 0x06, 0x76, 0xe5, 0x1c,
	0xfb, 0xb3, 0x84, 0xeb, 0xcb, 0x6c, 0xef, 0xfc, 0xa5, 0xf6, 0x74, 0x19, 0x95, 0xcd, 0x27, 0x59,
	0x17, 0x21, 0xda, 0x91, 0xac, 0x41, 0xc2, 0x09, 0xfc, 0x00, 0x0e, 0xe6, 0xb3, 0x19, 0x61, 0xfe,
	0x28, 0x09, 0x17, 0x5a, 0xb7, 0xb5, 0x59, 0xb7, 0xaf, 0xb8, 0x57, 0x49, 0xb8, 0x90, 0xe2, 0xd6,
	0x3f, 0x15, 0x50, 0xcf, 0x8e, 0xa9, 0xbc, 0x7b, 0x90, 0x7d, 0x63, 0x23, 0xbb, 0x7f, 0x6d, 0xfb,
	0x03, 0xd7, 0xe9, 0x7b, 0xa9, 0x8b, 0xe9, 0x14, 0x1c, 0xe5, 0xc1, 0xd5, 0xb5, 0xd4, 0x00, 0xc7,
	0x79, 0xe8, 0xda, 0xee, 0x7b, 0x36, 0xd2, 0x57, 0x52, 0x1e, 0xeb, 0x39, 0xdd, 0xee, 0x9d, 0xed,
	0xdf, 0xd9, 0x37, 0x9e, 0x59, 0x85, 0x4d, 0xf0, 0xc5, 0x06, 0x02, 0x72, 0x3e, 0xde, 0x7a, 0x66,
	0xad, 0xcc, 0x02, 0xd9, 0x97, 0x68, 0x49, 0x33, 0xb7, 0xe4, 0x95, 0x5a, 0x4a, 0x50, 0x3b, 0x6c,
	0xcb, 0x5b, 0xb3, 0x14, 0xd6, 0xfe, 0x2f, 0xca, 0x22, 0xb8, 0x41, 0xee, 0x73, 0x1c, 0xe6, 0x4e,
	0x99, 0x83, 0x66, 0xa8, 0x1d, 0x76, 0xcb, 0x22, 0xd4, 0xb8, 0xde, 0x02, 0xb4, 0xfe, 0x34, 0xc0,
	0x7e, 0xe6, 0x05, 0x26, 0x73, 0xd6, 0x73, 0x1f, 0xca, 0xbf, 0x01, 0x2c, 0x70, 0x98, 0xc3, 0x56,
	0x99, 0x96, 0x1f, 0x0f, 0x59, 0x44, 0xfe, 0x75, 0xdc, 0xfe, 0x25, 0xfa, 0xd1, 0xac, 0xc8, 0x1a,
	0xe5, 0xe0, 0x9e, 0xfb, 0xe0, 0xf4, 0x3f, 0x9a, 0xd5, 0x92, 0xfd, 0x86, 0x9e, 0x3b, 0x18, 0xd8,
	0x5d, 0xb3, 0x76, 0x55, 0xb9, 0x35, 0x46, 0xdb, 0xea, 0x23, 0xf0, 0xe2, 0xdf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x9f, 0x9e, 0xc1, 0x8b, 0x64, 0x0a, 0x00, 0x00,
}
