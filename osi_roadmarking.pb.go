// Code generated by protoc-gen-go. DO NOT EDIT.
// source: osi_roadmarking.proto

package osi3

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Definition of road marking types.
//
type RoadMarking_Classification_Type int32

const (
	// Type of road marking is unknown (must not be used in ground
	// truth).
	//
	RoadMarking_Classification_TYPE_UNKNOWN RoadMarking_Classification_Type = 0
	// Other (unspecified but known) type of road marking.
	//
	RoadMarking_Classification_TYPE_OTHER RoadMarking_Classification_Type = 1
	// Paint on the road surface indicating a color image of a traffic
	// sign.
	//
	RoadMarking_Classification_TYPE_PAINTED_TRAFFIC_SIGN RoadMarking_Classification_Type = 2
	// Paint on the road surface indicating a monochrome logical symbol
	// of a traffic sign (e.g. digits 50 as start of speed limit 50 or
	// stop line for stop sign).
	//
	RoadMarking_Classification_TYPE_SYMBOLIC_TRAFFIC_SIGN RoadMarking_Classification_Type = 3
	// Paint on the road surface as a character string (e.g. BUS as bus
	// only lane).
	//
	RoadMarking_Classification_TYPE_TEXTUAL_TRAFFIC_SIGN RoadMarking_Classification_Type = 4
	// Paint on the road surface indicating a generic symbol.
	//
	RoadMarking_Classification_TYPE_GENERIC_SYMBOL RoadMarking_Classification_Type = 5
	// Paint on the road surface indicating a generic line.
	//
	RoadMarking_Classification_TYPE_GENERIC_LINE RoadMarking_Classification_Type = 6
	// Paint on the road surface indicating a generic character string.
	//
	RoadMarking_Classification_TYPE_GENERIC_TEXT RoadMarking_Classification_Type = 7
)

var RoadMarking_Classification_Type_name = map[int32]string{
	0: "TYPE_UNKNOWN",
	1: "TYPE_OTHER",
	2: "TYPE_PAINTED_TRAFFIC_SIGN",
	3: "TYPE_SYMBOLIC_TRAFFIC_SIGN",
	4: "TYPE_TEXTUAL_TRAFFIC_SIGN",
	5: "TYPE_GENERIC_SYMBOL",
	6: "TYPE_GENERIC_LINE",
	7: "TYPE_GENERIC_TEXT",
}

var RoadMarking_Classification_Type_value = map[string]int32{
	"TYPE_UNKNOWN":               0,
	"TYPE_OTHER":                 1,
	"TYPE_PAINTED_TRAFFIC_SIGN":  2,
	"TYPE_SYMBOLIC_TRAFFIC_SIGN": 3,
	"TYPE_TEXTUAL_TRAFFIC_SIGN":  4,
	"TYPE_GENERIC_SYMBOL":        5,
	"TYPE_GENERIC_LINE":          6,
	"TYPE_GENERIC_TEXT":          7,
}

func (x RoadMarking_Classification_Type) String() string {
	return proto.EnumName(RoadMarking_Classification_Type_name, int32(x))
}

func (RoadMarking_Classification_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_476ffbfc60637059, []int{0, 0, 0}
}

// Definition of road marking colors
//
type RoadMarking_Classification_Color int32

const (
	// Color of road marking is unknown (must not be used in ground
	// truth).
	//
	RoadMarking_Classification_COLOR_UNKNOWN RoadMarking_Classification_Color = 0
	// Marking with another (unspecified but known) color.
	//
	RoadMarking_Classification_COLOR_OTHER RoadMarking_Classification_Color = 1
	// Marking with white color.
	//
	RoadMarking_Classification_COLOR_WHITE RoadMarking_Classification_Color = 2
	// Marking with yellow / orange-yellow color.
	//
	RoadMarking_Classification_COLOR_YELLOW RoadMarking_Classification_Color = 3
	// Marking with blue color.
	//
	RoadMarking_Classification_COLOR_BLUE RoadMarking_Classification_Color = 5
	// Marking with red color.
	//
	RoadMarking_Classification_COLOR_RED RoadMarking_Classification_Color = 6
	// Marking with green color.
	//
	RoadMarking_Classification_COLOR_GREEN RoadMarking_Classification_Color = 7
	// Marking with violet color.
	//
	RoadMarking_Classification_COLOR_VIOLET RoadMarking_Classification_Color = 8
)

var RoadMarking_Classification_Color_name = map[int32]string{
	0: "COLOR_UNKNOWN",
	1: "COLOR_OTHER",
	2: "COLOR_WHITE",
	3: "COLOR_YELLOW",
	5: "COLOR_BLUE",
	6: "COLOR_RED",
	7: "COLOR_GREEN",
	8: "COLOR_VIOLET",
}

var RoadMarking_Classification_Color_value = map[string]int32{
	"COLOR_UNKNOWN": 0,
	"COLOR_OTHER":   1,
	"COLOR_WHITE":   2,
	"COLOR_YELLOW":  3,
	"COLOR_BLUE":    5,
	"COLOR_RED":     6,
	"COLOR_GREEN":   7,
	"COLOR_VIOLET":  8,
}

func (x RoadMarking_Classification_Color) String() string {
	return proto.EnumName(RoadMarking_Classification_Color_name, int32(x))
}

func (RoadMarking_Classification_Color) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_476ffbfc60637059, []int{0, 0, 1}
}

//
type RoadMarking struct {
	// The ID of the road marking.
	//
	Id *Identifier `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The base parameters of the road marking.
	//
	// The orientation of the bounding box \c #base
	// \c BaseStationary::orientation is defined as follows:
	// The z-axis of the \c BaseStationary::orientation is the vector from the
	// 'bottom' to the 'top' of the road marking's (i.e. painted traffic sign)
	// 2D image area.
	// (Normally it is in the ground truth xy-plain.)
	// The x-axis of the \c BaseStationary::orientation is the view normal of
	// the road marking's 2D image area.
	// Normally this x-axis points to the sky.
	//
	// \note If a valid unidirectional road marking is assigned to the host
	// vehicle's current lane and the driving direction of the latter roughly
	// matches the z-axis of the \c #base \c BaseStationary::orientation then
	// the road marking is of relevance to (i.e. in effect for) the host
	// vehicle.
	//
	Base *BaseStationary `protobuf:"bytes,2,opt,name=base,proto3" json:"base,omitempty"`
	// The classification data for the road marking.
	//
	Classification       *RoadMarking_Classification `protobuf:"bytes,3,opt,name=classification,proto3" json:"classification,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *RoadMarking) Reset()         { *m = RoadMarking{} }
func (m *RoadMarking) String() string { return proto.CompactTextString(m) }
func (*RoadMarking) ProtoMessage()    {}
func (*RoadMarking) Descriptor() ([]byte, []int) {
	return fileDescriptor_476ffbfc60637059, []int{0}
}

func (m *RoadMarking) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoadMarking.Unmarshal(m, b)
}
func (m *RoadMarking) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoadMarking.Marshal(b, m, deterministic)
}
func (m *RoadMarking) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoadMarking.Merge(m, src)
}
func (m *RoadMarking) XXX_Size() int {
	return xxx_messageInfo_RoadMarking.Size(m)
}
func (m *RoadMarking) XXX_DiscardUnknown() {
	xxx_messageInfo_RoadMarking.DiscardUnknown(m)
}

var xxx_messageInfo_RoadMarking proto.InternalMessageInfo

func (m *RoadMarking) GetId() *Identifier {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *RoadMarking) GetBase() *BaseStationary {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *RoadMarking) GetClassification() *RoadMarking_Classification {
	if m != nil {
		return m.Classification
	}
	return nil
}

//
// \brief \c Classification data for a road surface marking.
//
type RoadMarking_Classification struct {
	// The type of the road marking.
	//
	Type RoadMarking_Classification_Type `protobuf:"varint,1,opt,name=type,proto3,enum=osi3.RoadMarking_Classification_Type" json:"type,omitempty"`
	// Traffic sign as road marking (color image, monochrome image or
	// character string).
	//
	// \note Field is set if ( \c #type == \c #TYPE_PAINTED_TRAFFIC_SIGN or
	// \c #TYPE_SYMBOLIC_TRAFFIC_SIGN or \c #TYPE_TEXTUAL_TRAFFIC_SIGN ).
	//
	// \note Field need not be set (or set to \c #TYPE_OTHER)
	// if road marking type (\c #type) does not require it.
	//
	TrafficMainSignType TrafficSign_MainSign_Classification_Type `protobuf:"varint,2,opt,name=traffic_main_sign_type,json=trafficMainSignType,proto3,enum=osi3.TrafficSign_MainSign_Classification_Type" json:"traffic_main_sign_type,omitempty"`
	// The monochrome color of the road marking.
	// \note Field need not be set (or set to \c #COLOR_OTHER)
	// if road marking type does not require it (e.g. for \c #type ==
	// \c #TYPE_PAINTED_TRAFFIC_SIGN).
	//
	MonochromeColor RoadMarking_Classification_Color `protobuf:"varint,3,opt,name=monochrome_color,json=monochromeColor,proto3,enum=osi3.RoadMarking_Classification_Color" json:"monochrome_color,omitempty"`
	// Additional value associated with the road marking, e.g. value of the
	// speed limit.
	//
	// \note Field need not be set if road marking type does not require it.
	//
	Value *TrafficSignValue `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	// Additional text value as road marking, e.g. BUS, TAXI etc.
	//
	// \note Field need not be set if road marking type does not require it.
	//
	ValueText string `protobuf:"bytes,5,opt,name=value_text,json=valueText,proto3" json:"value_text,omitempty"`
	// The ID(s) of the lane(s) that the road marking is assigned to.
	// May be multiple if the road marking goes across multiple lanes.
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	AssignedLaneId       []*Identifier `protobuf:"bytes,6,rep,name=assigned_lane_id,json=assignedLaneId,proto3" json:"assigned_lane_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RoadMarking_Classification) Reset()         { *m = RoadMarking_Classification{} }
func (m *RoadMarking_Classification) String() string { return proto.CompactTextString(m) }
func (*RoadMarking_Classification) ProtoMessage()    {}
func (*RoadMarking_Classification) Descriptor() ([]byte, []int) {
	return fileDescriptor_476ffbfc60637059, []int{0, 0}
}

func (m *RoadMarking_Classification) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoadMarking_Classification.Unmarshal(m, b)
}
func (m *RoadMarking_Classification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoadMarking_Classification.Marshal(b, m, deterministic)
}
func (m *RoadMarking_Classification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoadMarking_Classification.Merge(m, src)
}
func (m *RoadMarking_Classification) XXX_Size() int {
	return xxx_messageInfo_RoadMarking_Classification.Size(m)
}
func (m *RoadMarking_Classification) XXX_DiscardUnknown() {
	xxx_messageInfo_RoadMarking_Classification.DiscardUnknown(m)
}

var xxx_messageInfo_RoadMarking_Classification proto.InternalMessageInfo

func (m *RoadMarking_Classification) GetType() RoadMarking_Classification_Type {
	if m != nil {
		return m.Type
	}
	return RoadMarking_Classification_TYPE_UNKNOWN
}

func (m *RoadMarking_Classification) GetTrafficMainSignType() TrafficSign_MainSign_Classification_Type {
	if m != nil {
		return m.TrafficMainSignType
	}
	return TrafficSign_MainSign_Classification_TYPE_UNKNOWN
}

func (m *RoadMarking_Classification) GetMonochromeColor() RoadMarking_Classification_Color {
	if m != nil {
		return m.MonochromeColor
	}
	return RoadMarking_Classification_COLOR_UNKNOWN
}

func (m *RoadMarking_Classification) GetValue() *TrafficSignValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RoadMarking_Classification) GetValueText() string {
	if m != nil {
		return m.ValueText
	}
	return ""
}

func (m *RoadMarking_Classification) GetAssignedLaneId() []*Identifier {
	if m != nil {
		return m.AssignedLaneId
	}
	return nil
}

func init() {
	proto.RegisterEnum("osi3.RoadMarking_Classification_Type", RoadMarking_Classification_Type_name, RoadMarking_Classification_Type_value)
	proto.RegisterEnum("osi3.RoadMarking_Classification_Color", RoadMarking_Classification_Color_name, RoadMarking_Classification_Color_value)
	proto.RegisterType((*RoadMarking)(nil), "osi3.RoadMarking")
	proto.RegisterType((*RoadMarking_Classification)(nil), "osi3.RoadMarking.Classification")
}

func init() { proto.RegisterFile("osi_roadmarking.proto", fileDescriptor_476ffbfc60637059) }

var fileDescriptor_476ffbfc60637059 = []byte{
	// 553 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0x4f, 0x4f, 0xdb, 0x3c,
	0x18, 0x7f, 0x93, 0x26, 0xe5, 0xe5, 0x61, 0x04, 0x63, 0x06, 0xcb, 0x2a, 0x31, 0x55, 0x48, 0x9b,
	0x38, 0x4c, 0x39, 0xc0, 0x69, 0xbb, 0xd1, 0x62, 0x68, 0xb4, 0x90, 0x30, 0x37, 0xc0, 0x38, 0x45,
	0x26, 0x71, 0x99, 0xb5, 0x26, 0x46, 0x49, 0x36, 0xc1, 0xb7, 0xd8, 0x65, 0x1f, 0x6b, 0x9f, 0x65,
	0x5f, 0x61, 0xb2, 0x0d, 0x94, 0x0e, 0x24, 0x6e, 0xf6, 0xef, 0x9f, 0x9f, 0xe7, 0x17, 0x05, 0xd6,
	0x65, 0x23, 0xb2, 0x5a, 0xb2, 0xa2, 0x64, 0xf5, 0x37, 0x51, 0x5d, 0x06, 0x57, 0xb5, 0x6c, 0x25,
	0x76, 0x64, 0x23, 0x76, 0x7b, 0x48, 0x91, 0xb9, 0x2c, 0x4b, 0x59, 0x19, 0xbc, 0xa7, 0xe5, 0x6d,
	0xcd, 0x26, 0x13, 0x91, 0x37, 0xe2, 0xf2, 0x16, 0xde, 0xfa, 0xb5, 0x00, 0x4b, 0x54, 0xb2, 0xe2,
	0xc8, 0x84, 0xe0, 0x3e, 0xd8, 0xa2, 0xf0, 0xad, 0xbe, 0xb5, 0xbd, 0xb4, 0x83, 0x02, 0x95, 0x15,
	0x84, 0x05, 0xaf, 0x5a, 0x31, 0x11, 0xbc, 0xa6, 0xb6, 0x28, 0xf0, 0x36, 0x38, 0x17, 0xac, 0xe1,
	0xbe, 0xad, 0x35, 0x2f, 0x8d, 0x66, 0xc0, 0x1a, 0x3e, 0x6e, 0x59, 0x2b, 0x64, 0xc5, 0xea, 0x1b,
	0xaa, 0x15, 0x78, 0x04, 0x5e, 0x3e, 0x65, 0x4d, 0x23, 0x26, 0x22, 0xd7, 0x94, 0xdf, 0xd1, 0x9e,
	0xbe, 0xf1, 0x3c, 0x78, 0x36, 0x18, 0xce, 0xe9, 0xe8, 0x3f, 0xbe, 0xde, 0x1f, 0x17, 0xbc, 0x79,
	0x09, 0xfe, 0x00, 0x4e, 0x7b, 0x73, 0xc5, 0xf5, 0xa8, 0xde, 0xce, 0xdb, 0xe7, 0x22, 0x83, 0xf4,
	0xe6, 0x8a, 0x53, 0x6d, 0xc1, 0x39, 0x6c, 0xdc, 0x16, 0x91, 0x95, 0x4c, 0x54, 0x99, 0xaa, 0x23,
	0xd3, 0x61, 0xb6, 0x0e, 0x0b, 0x4c, 0x58, 0x6a, 0x34, 0x63, 0x55, 0xd6, 0x11, 0x13, 0x95, 0x3e,
	0x3c, 0x95, 0xba, 0x76, 0x9b, 0x76, 0x27, 0x52, 0x20, 0xfe, 0x0c, 0xa8, 0x94, 0x95, 0xcc, 0xbf,
	0xd6, 0xb2, 0xe4, 0x59, 0x2e, 0xa7, 0xb2, 0xd6, 0xeb, 0x7b, 0x3b, 0xef, 0x9e, 0x9d, 0x75, 0xa8,
	0xd4, 0x74, 0x65, 0xe6, 0xd7, 0x00, 0x7e, 0x0f, 0xee, 0x0f, 0x36, 0xfd, 0xce, 0x7d, 0x47, 0xd7,
	0xb8, 0xf1, 0x68, 0xcc, 0x53, 0xc5, 0x52, 0x23, 0xc2, 0x9b, 0x00, 0xfa, 0x90, 0xb5, 0xfc, 0xba,
	0xf5, 0xdd, 0xbe, 0xb5, 0xbd, 0x48, 0x17, 0x35, 0x92, 0xf2, 0xeb, 0x16, 0x7f, 0x04, 0xa4, 0xde,
	0xbc, 0xac, 0x78, 0x91, 0x4d, 0x59, 0xc5, 0x33, 0x51, 0xf8, 0xdd, 0x7e, 0xe7, 0xc9, 0xcf, 0xee,
	0xdd, 0x29, 0x23, 0x56, 0xf1, 0xb0, 0xd8, 0xfa, 0x6d, 0x81, 0xa3, 0x97, 0x44, 0xf0, 0x22, 0x3d,
	0x3f, 0x26, 0xd9, 0x49, 0xfc, 0x29, 0x4e, 0xce, 0x62, 0xf4, 0x1f, 0xf6, 0x00, 0x34, 0x92, 0xa4,
	0x23, 0x42, 0x91, 0x85, 0x37, 0xe1, 0xb5, 0xbe, 0x1f, 0xef, 0x85, 0x71, 0x4a, 0xf6, 0xb3, 0x94,
	0xee, 0x1d, 0x1c, 0x84, 0xc3, 0x6c, 0x1c, 0x1e, 0xc6, 0xc8, 0xc6, 0x6f, 0xa0, 0xa7, 0xe9, 0xf1,
	0xf9, 0xd1, 0x20, 0x89, 0xc2, 0xe1, 0x3c, 0xdf, 0xb9, 0xb7, 0xa7, 0xe4, 0x4b, 0x7a, 0xb2, 0x17,
	0xcd, 0xd3, 0x0e, 0x7e, 0x05, 0x6b, 0x9a, 0x3e, 0x24, 0x31, 0xa1, 0x0a, 0xd6, 0x31, 0xc8, 0xc5,
	0xeb, 0xb0, 0x3a, 0x47, 0x44, 0x61, 0x4c, 0x50, 0xf7, 0x11, 0xac, 0x62, 0xd1, 0xc2, 0xd6, 0x4f,
	0x0b, 0x5c, 0x53, 0xf1, 0x2a, 0x2c, 0x0f, 0x93, 0x28, 0xa1, 0x0f, 0x36, 0x5a, 0x81, 0x25, 0x03,
	0xdd, 0xad, 0x74, 0x0f, 0x9c, 0x8d, 0xc2, 0x94, 0x20, 0x5b, 0xb5, 0x60, 0x80, 0x73, 0x12, 0x45,
	0xc9, 0x19, 0xea, 0xa8, 0x16, 0x0c, 0x32, 0x88, 0x4e, 0x08, 0x72, 0xf1, 0x32, 0x2c, 0x9a, 0x3b,
	0x25, 0xfb, 0xa8, 0x3b, 0x4b, 0x38, 0xa4, 0x84, 0xc4, 0x68, 0x61, 0x96, 0x70, 0x1a, 0x26, 0x11,
	0x49, 0xd1, 0xff, 0x03, 0x7b, 0x64, 0x5d, 0x74, 0xf5, 0x2f, 0xba, 0xfb, 0x37, 0x00, 0x00, 0xff,
	0xff, 0x1e, 0x3e, 0xe7, 0xf9, 0xea, 0x03, 0x00, 0x00,
}
