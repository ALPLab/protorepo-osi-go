// Code generated by protoc-gen-go. DO NOT EDIT.
// source: osi_sensorviewconfiguration.proto

package osi3

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Channel format.
//
type CameraSensorViewConfiguration_ChannelFormat int32

const (
	// Type of channel format is unknown (must not be used).
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_UNKNOWN CameraSensorViewConfiguration_ChannelFormat = 0
	// Unspecified but known channel format.
	// Consider proposing an additional format if using
	// \c #CHANNEL_FORMAT_OTHER.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_OTHER CameraSensorViewConfiguration_ChannelFormat = 1
	// Single Luminance Channel UINT8 Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_MONO_U8_LIN CameraSensorViewConfiguration_ChannelFormat = 2
	// Single Luminance Channel UINT16 Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_MONO_U16_LIN CameraSensorViewConfiguration_ChannelFormat = 3
	// Single Luminance Channel UINT32 Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_MONO_U32_LIN CameraSensorViewConfiguration_ChannelFormat = 4
	// Single Luminance Channel Single Precision FP Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_MONO_F32_LIN CameraSensorViewConfiguration_ChannelFormat = 5
	// Packed RGB Channels (no padding) UINT8 Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_RGB_U8_LIN CameraSensorViewConfiguration_ChannelFormat = 6
	// Packed RGB Channels (no padding) UINT16 Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_RGB_U16_LIN CameraSensorViewConfiguration_ChannelFormat = 7
	// Packed RGB Channels (no padding) UINT32 Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_RGB_U32_LIN CameraSensorViewConfiguration_ChannelFormat = 8
	// Packed RGB Channels (no padding) Single Precision FP Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_RGB_F32_LIN CameraSensorViewConfiguration_ChannelFormat = 9
	// Bayer RGGB Channels UINT8 FP Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_BAYER_BGGR_U8_LIN CameraSensorViewConfiguration_ChannelFormat = 10
	// Bayer RGGB Channels UINT16 FP Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_BAYER_BGGR_U16_LIN CameraSensorViewConfiguration_ChannelFormat = 11
	// Bayer RGGB Channels UINT32 FP Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_BAYER_BGGR_U32_LIN CameraSensorViewConfiguration_ChannelFormat = 12
	// Bayer RGGB Channels Single Precision FP Linear.
	//
	CameraSensorViewConfiguration_CHANNEL_FORMAT_BAYER_BGGR_F32_LIN CameraSensorViewConfiguration_ChannelFormat = 13
)

var CameraSensorViewConfiguration_ChannelFormat_name = map[int32]string{
	0:  "CHANNEL_FORMAT_UNKNOWN",
	1:  "CHANNEL_FORMAT_OTHER",
	2:  "CHANNEL_FORMAT_MONO_U8_LIN",
	3:  "CHANNEL_FORMAT_MONO_U16_LIN",
	4:  "CHANNEL_FORMAT_MONO_U32_LIN",
	5:  "CHANNEL_FORMAT_MONO_F32_LIN",
	6:  "CHANNEL_FORMAT_RGB_U8_LIN",
	7:  "CHANNEL_FORMAT_RGB_U16_LIN",
	8:  "CHANNEL_FORMAT_RGB_U32_LIN",
	9:  "CHANNEL_FORMAT_RGB_F32_LIN",
	10: "CHANNEL_FORMAT_BAYER_BGGR_U8_LIN",
	11: "CHANNEL_FORMAT_BAYER_BGGR_U16_LIN",
	12: "CHANNEL_FORMAT_BAYER_BGGR_U32_LIN",
	13: "CHANNEL_FORMAT_BAYER_BGGR_F32_LIN",
}

var CameraSensorViewConfiguration_ChannelFormat_value = map[string]int32{
	"CHANNEL_FORMAT_UNKNOWN":            0,
	"CHANNEL_FORMAT_OTHER":              1,
	"CHANNEL_FORMAT_MONO_U8_LIN":        2,
	"CHANNEL_FORMAT_MONO_U16_LIN":       3,
	"CHANNEL_FORMAT_MONO_U32_LIN":       4,
	"CHANNEL_FORMAT_MONO_F32_LIN":       5,
	"CHANNEL_FORMAT_RGB_U8_LIN":         6,
	"CHANNEL_FORMAT_RGB_U16_LIN":        7,
	"CHANNEL_FORMAT_RGB_U32_LIN":        8,
	"CHANNEL_FORMAT_RGB_F32_LIN":        9,
	"CHANNEL_FORMAT_BAYER_BGGR_U8_LIN":  10,
	"CHANNEL_FORMAT_BAYER_BGGR_U16_LIN": 11,
	"CHANNEL_FORMAT_BAYER_BGGR_U32_LIN": 12,
	"CHANNEL_FORMAT_BAYER_BGGR_F32_LIN": 13,
}

func (x CameraSensorViewConfiguration_ChannelFormat) String() string {
	return proto.EnumName(CameraSensorViewConfiguration_ChannelFormat_name, int32(x))
}

func (CameraSensorViewConfiguration_ChannelFormat) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{4, 0}
}

//
// \brief The configuration settings for the \c SensorView to be provided
// by the environment simulation.
//
// This message can be provided by the sensor model to the environment
// simulation, in which case it describes the input configuration that
// is desired by the sensor model. In response the environment simulation
// will configure the input and provide a new message of this type, which
// describes the actual configuration that it is going to employ. The two
// can and will differ, when either the environment simulation does not
// support a given requested configuration, and/or when the requested
// configuration allowed for multiple alternatives, in which case the set
// configuration will only contain the alternative chosen.
//
// It should be noted that this message is not intended to provide for
// parametrization of a generic sensor model, but rather for the automatic
// configuration of an environment simulation in order to supply the
// necessary input to it, depending on its actual configuration.
// Mechanisms to parametrize sensor models are currently packaging-specific,
// i.e. they depend on the packaging mechanism chosen:  For FMU-packaging
// the parametrization can be implemented using normal FMU parameters,
// and the requested \c SensorViewConfiguration can depend on those parameter
// values by being defined as a calculatedParameter.
//
// The sensor-technology specific configurations are intended to allow
// sensor models to use useful sensor modeling base capabilities of the
// environment simulation (e.g. ray tracing engines, camera/lens image
// generation), which need configuration by the sensor model to supply
// suitable data. The specified details are not directly related to
// sensor details, but rather provide the necessary base machinery
// setup so that the data provided is suitable to model the sensor to
// a sufficient degree of fidelity internally. For example the number
// of rays parameters for the Lidar configuration does not match one to
// one with the number of laser rays a lidar sensor might cast, but
// rather specifies the number of rays being cast by a ray
// casting/tracing engine, which might be many more than the physical
// rays being cast at any point in time.
//
// This also implies that for sensors that have dynamically varying
// characteristics (e.g. switching between wide and narrow focus,
// switching update rates, etc.), the basic approach is to specify
// the maximum amount of data needed at all times here, and internally
// select the data that is needed at any point in time.
//
// In order to optimize the workload and bandwidth needed for sensor
// simulation, OSI packaging mechanisms can specify the ability to
// exchange \c SensorViewConfiguration messages not only prior to
// simulation startup, but also dynamically during simulation runs,
// thereby allowing dynamic input configuration switching to only
// request data that is needed in the current sensor mode. However
// this is more or less only a resource optimization strategy, and
// since providing fine-grained information like this can reveal
// internal characteristics of the sensor and/or sensor model, will
// not always be the preferred approach for reasons of IP protection.
//
type SensorViewConfiguration struct {
	// The interface version used by the sender (simulation environment).
	//
	Version *InterfaceVersion `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// The ID of the sensor at host vehicle's mounting_position.
	//
	// This is the ID of the virtual sensor, to be used in its detected
	// object output; it is distinct from the IDs of its physical detectors,
	// which are used in the detected features.
	//
	// The ID is to be provided by the environment simulation, the sensor
	// model is not in a position to provide a useful default value.
	//
	SensorId *Identifier `protobuf:"bytes,2,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// The virtual mounting position of the sensor (origin and orientation
	// of the sensor coordinate system) given in vehicle coordinates [1].
	// The virtual position pertains to the sensor as a whole, regardless
	// of the actual position of individual physical detectors, and governs
	// the sensor-relative coordinates in detected objects of the sensor
	// as a whole. Individual features detected by individual physical
	// detectors are governed by the actual physical mounting positions
	// of the detectors, as indicated in the technology-specific sub-views
	// and sub-view configurations.
	//
	// \arg \b x-direction of sensor coordinate system: sensor viewing direction
	// \arg \b z-direction of sensor coordinate system: sensor (up)
	// \arg \b y-direction of sensor coordinate system: perpendicular to x and z
	// right hand system
	//
	// \par References:
	// - [1] DIN ISO 8855:2013-11
	//
	// \note The origin of vehicle's coordinate system in world frame is
	// ( \c MovingObject::base . \c BaseMoving::position +
	// Inverse_Rotation_yaw_pitch_roll( \c MovingObject::base . \c
	// BaseMoving::orientation) * \c
	// MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
	// the vehicle's coordinate system is equal to the orientation of the
	// vehicle's bounding box \c MovingObject::base . \c
	// BaseMoving::orientation. \note A default position can be provided by the
	// sensor model (e.g. to indicate the position the model was validated for),
	// but this is optional; the environment simulation must provide a valid
	// mounting position (based on the vehicle configuration) when setting the
	// view configuration.
	//
	MountingPosition *MountingPosition `protobuf:"bytes,3,opt,name=mounting_position,json=mountingPosition,proto3" json:"mounting_position,omitempty"`
	// The root mean squared error of the mounting position.
	//
	MountingPositionRmse *MountingPosition `protobuf:"bytes,4,opt,name=mounting_position_rmse,json=mountingPositionRmse,proto3" json:"mounting_position_rmse,omitempty"`
	// Field of View in horizontal orientation of the sensor.
	//
	// This determines the limit of the cone of interest of ground truth
	// that the simulation environment has to provide.
	// Viewing range: [- \c #field_of_view_horizontal/2,  \c
	// #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \c
	// Spherical3d. Unit: [rad]
	FieldOfViewHorizontal float64 `protobuf:"fixed64,5,opt,name=field_of_view_horizontal,json=fieldOfViewHorizontal,proto3" json:"field_of_view_horizontal,omitempty"`
	// Field of View in vertical orientation of the sensor.
	//
	// This determines the limit of the cone of interest of ground truth
	// that the simulation environment has to provide.
	// Viewing range: [- \c #field_of_view_vertical/2,  \c
	// #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
	// as defined in \c Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewVertical float64 `protobuf:"fixed64,6,opt,name=field_of_view_vertical,json=fieldOfViewVertical,proto3" json:"field_of_view_vertical,omitempty"`
	// Maximum range of the sensor
	//
	// This determines the limit of the cone of interest of ground truth
	// that the simulation environment has to provide.
	//
	// Unit: [m]
	Range float64 `protobuf:"fixed64,7,opt,name=range,proto3" json:"range,omitempty"`
	// The update cycle time of the sensor model.
	//
	// This specifies the rate at which the sensor model is provided with
	// new input data.
	//
	// Unit: [s]
	// \note In the case of FMU packaging this will correspond to the
	// communication step size.
	UpdateCycleTime *Timestamp `protobuf:"bytes,8,opt,name=update_cycle_time,json=updateCycleTime,proto3" json:"update_cycle_time,omitempty"`
	// Initial update cycle offset of the sensor model.
	//
	// This specifies the initial offset (i.e. initial delay) of the
	// sensor model update cycle that the simulation should take into
	// account. It is defined against a simulation start time of 0:
	// i.e. an initial offset of 0.008s would mean, that the initial
	// update of sensor input data to the model should occur at 0+0.008s,
	// and then update_cycle_time after that, etc. If the simulation
	// start time of the simulation is non-zero, then the offset still
	// has to be interpreted against a 0 start time, and not simply
	// added on top of the start time: e.g. if the simulation starts at
	// 0.030s, and the update cycle time is 0.020s, then the first
	// update to the sensor input should happen at 0.048s, or 0.018s
	// after simulation start. This convention is needed to ensure
	// stable phase position of the offset in the case of changing
	// simulation start times, e.g. for partial resimulation.
	//
	// Unit: [s]
	UpdateCycleOffset *Timestamp `protobuf:"bytes,9,opt,name=update_cycle_offset,json=updateCycleOffset,proto3" json:"update_cycle_offset,omitempty"`
	// Simulation Start time
	//
	// This specifies the simulation start time that the Simulation
	// has chosen. This field has no defined meaning if provided by
	// the sensor model.
	//
	// Unit: [s]
	SimulationStartTime *Timestamp `protobuf:"bytes,10,opt,name=simulation_start_time,json=simulationStartTime,proto3" json:"simulation_start_time,omitempty"`
	// Generic Sensor View Configuration(s).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	GenericSensorViewConfiguration []*GenericSensorViewConfiguration `protobuf:"bytes,1000,rep,name=generic_sensor_view_configuration,json=genericSensorViewConfiguration,proto3" json:"generic_sensor_view_configuration,omitempty"`
	// Radar-specific Sensor View Configuration(s).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	RadarSensorViewConfiguration []*RadarSensorViewConfiguration `protobuf:"bytes,1001,rep,name=radar_sensor_view_configuration,json=radarSensorViewConfiguration,proto3" json:"radar_sensor_view_configuration,omitempty"`
	// Lidar-specific Sensor View Configuration(s).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	LidarSensorViewConfiguration []*LidarSensorViewConfiguration `protobuf:"bytes,1002,rep,name=lidar_sensor_view_configuration,json=lidarSensorViewConfiguration,proto3" json:"lidar_sensor_view_configuration,omitempty"`
	// Camera-specific Sensor View Configuration(s).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	CameraSensorViewConfiguration []*CameraSensorViewConfiguration `protobuf:"bytes,1003,rep,name=camera_sensor_view_configuration,json=cameraSensorViewConfiguration,proto3" json:"camera_sensor_view_configuration,omitempty"`
	// Ultrasonic-specific Sensor View Configuration(s).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	UltrasonicSensorViewConfiguration []*UltrasonicSensorViewConfiguration `protobuf:"bytes,1004,rep,name=ultrasonic_sensor_view_configuration,json=ultrasonicSensorViewConfiguration,proto3" json:"ultrasonic_sensor_view_configuration,omitempty"`
	XXX_NoUnkeyedLiteral              struct{}                             `json:"-"`
	XXX_unrecognized                  []byte                               `json:"-"`
	XXX_sizecache                     int32                                `json:"-"`
}

func (m *SensorViewConfiguration) Reset()         { *m = SensorViewConfiguration{} }
func (m *SensorViewConfiguration) String() string { return proto.CompactTextString(m) }
func (*SensorViewConfiguration) ProtoMessage()    {}
func (*SensorViewConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{0}
}

func (m *SensorViewConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SensorViewConfiguration.Unmarshal(m, b)
}
func (m *SensorViewConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SensorViewConfiguration.Marshal(b, m, deterministic)
}
func (m *SensorViewConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorViewConfiguration.Merge(m, src)
}
func (m *SensorViewConfiguration) XXX_Size() int {
	return xxx_messageInfo_SensorViewConfiguration.Size(m)
}
func (m *SensorViewConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorViewConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_SensorViewConfiguration proto.InternalMessageInfo

func (m *SensorViewConfiguration) GetVersion() *InterfaceVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *SensorViewConfiguration) GetSensorId() *Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

func (m *SensorViewConfiguration) GetMountingPosition() *MountingPosition {
	if m != nil {
		return m.MountingPosition
	}
	return nil
}

func (m *SensorViewConfiguration) GetMountingPositionRmse() *MountingPosition {
	if m != nil {
		return m.MountingPositionRmse
	}
	return nil
}

func (m *SensorViewConfiguration) GetFieldOfViewHorizontal() float64 {
	if m != nil {
		return m.FieldOfViewHorizontal
	}
	return 0
}

func (m *SensorViewConfiguration) GetFieldOfViewVertical() float64 {
	if m != nil {
		return m.FieldOfViewVertical
	}
	return 0
}

func (m *SensorViewConfiguration) GetRange() float64 {
	if m != nil {
		return m.Range
	}
	return 0
}

func (m *SensorViewConfiguration) GetUpdateCycleTime() *Timestamp {
	if m != nil {
		return m.UpdateCycleTime
	}
	return nil
}

func (m *SensorViewConfiguration) GetUpdateCycleOffset() *Timestamp {
	if m != nil {
		return m.UpdateCycleOffset
	}
	return nil
}

func (m *SensorViewConfiguration) GetSimulationStartTime() *Timestamp {
	if m != nil {
		return m.SimulationStartTime
	}
	return nil
}

func (m *SensorViewConfiguration) GetGenericSensorViewConfiguration() []*GenericSensorViewConfiguration {
	if m != nil {
		return m.GenericSensorViewConfiguration
	}
	return nil
}

func (m *SensorViewConfiguration) GetRadarSensorViewConfiguration() []*RadarSensorViewConfiguration {
	if m != nil {
		return m.RadarSensorViewConfiguration
	}
	return nil
}

func (m *SensorViewConfiguration) GetLidarSensorViewConfiguration() []*LidarSensorViewConfiguration {
	if m != nil {
		return m.LidarSensorViewConfiguration
	}
	return nil
}

func (m *SensorViewConfiguration) GetCameraSensorViewConfiguration() []*CameraSensorViewConfiguration {
	if m != nil {
		return m.CameraSensorViewConfiguration
	}
	return nil
}

func (m *SensorViewConfiguration) GetUltrasonicSensorViewConfiguration() []*UltrasonicSensorViewConfiguration {
	if m != nil {
		return m.UltrasonicSensorViewConfiguration
	}
	return nil
}

//
// \brief The configuration settings for the Generic Sensor View to be provided
// by the environment simulation.
//
type GenericSensorViewConfiguration struct {
	// The ID of the sensor at host vehicle's mounting_position.
	//
	// This is the ID of the physical sensor, to be used in its detected
	// features output; it is distinct from the ID of its virtual sensor.
	//
	// The ID is to be provided by the environment simulation, the sensor
	// model is not in a position to provide a useful default value.
	//
	SensorId *Identifier `protobuf:"bytes,1,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// The physical mounting position of the sensor (origin and orientation
	// of the sensor coordinate system) given in vehicle coordinates [1].
	// The physical position pertains to this detector individually, and
	// governs the sensor-relative coordinates in features detected by this
	// detector.
	//
	// \arg \b x-direction of sensor coordinate system: sensor viewing direction
	// \arg \b z-direction of sensor coordinate system: sensor (up)
	// \arg \b y-direction of sensor coordinate system: perpendicular to x and z
	// right hand system
	//
	// \par References:
	// - [1] DIN ISO 8855:2013-11
	//
	// \note The origin of vehicle's coordinate system in world frame is
	// ( \c MovingObject::base . \c BaseMoving::position +
	// Inverse_Rotation_yaw_pitch_roll( \c MovingObject::base . \c
	// BaseMoving::orientation) * \c
	// MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
	// the vehicle's coordinate system is equal to the orientation of the
	// vehicle's bounding box \c MovingObject::base . \c
	// BaseMoving::orientation. \note A default position can be provided by the
	// sensor model (e.g. to indicate the position the model was validated for),
	// but this is optional; the environment simulation must provide a valid
	// mounting position (based on the vehicle configuration) when setting the
	// view configuration.
	//
	MountingPosition *MountingPosition `protobuf:"bytes,2,opt,name=mounting_position,json=mountingPosition,proto3" json:"mounting_position,omitempty"`
	// The root mean squared error of the mounting position.
	//
	MountingPositionRmse *MountingPosition `protobuf:"bytes,3,opt,name=mounting_position_rmse,json=mountingPositionRmse,proto3" json:"mounting_position_rmse,omitempty"`
	// Field of View in horizontal orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_horizontal/2,  \c
	// #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \c
	// Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewHorizontal float64 `protobuf:"fixed64,4,opt,name=field_of_view_horizontal,json=fieldOfViewHorizontal,proto3" json:"field_of_view_horizontal,omitempty"`
	// Field of View in vertical orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_vertical/2,  \c
	// #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
	// as defined in \c Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewVertical  float64  `protobuf:"fixed64,5,opt,name=field_of_view_vertical,json=fieldOfViewVertical,proto3" json:"field_of_view_vertical,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenericSensorViewConfiguration) Reset()         { *m = GenericSensorViewConfiguration{} }
func (m *GenericSensorViewConfiguration) String() string { return proto.CompactTextString(m) }
func (*GenericSensorViewConfiguration) ProtoMessage()    {}
func (*GenericSensorViewConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{1}
}

func (m *GenericSensorViewConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenericSensorViewConfiguration.Unmarshal(m, b)
}
func (m *GenericSensorViewConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenericSensorViewConfiguration.Marshal(b, m, deterministic)
}
func (m *GenericSensorViewConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericSensorViewConfiguration.Merge(m, src)
}
func (m *GenericSensorViewConfiguration) XXX_Size() int {
	return xxx_messageInfo_GenericSensorViewConfiguration.Size(m)
}
func (m *GenericSensorViewConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericSensorViewConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_GenericSensorViewConfiguration proto.InternalMessageInfo

func (m *GenericSensorViewConfiguration) GetSensorId() *Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

func (m *GenericSensorViewConfiguration) GetMountingPosition() *MountingPosition {
	if m != nil {
		return m.MountingPosition
	}
	return nil
}

func (m *GenericSensorViewConfiguration) GetMountingPositionRmse() *MountingPosition {
	if m != nil {
		return m.MountingPositionRmse
	}
	return nil
}

func (m *GenericSensorViewConfiguration) GetFieldOfViewHorizontal() float64 {
	if m != nil {
		return m.FieldOfViewHorizontal
	}
	return 0
}

func (m *GenericSensorViewConfiguration) GetFieldOfViewVertical() float64 {
	if m != nil {
		return m.FieldOfViewVertical
	}
	return 0
}

//
// \brief The configuration settings for the Radar Sensor View to be provided
// by the environment simulation.
//
type RadarSensorViewConfiguration struct {
	// The ID of the sensor at host vehicle's mounting_position.
	//
	// This is the ID of the physical sensor, to be used in its detected
	// features output; it is distinct from the ID of its virtual sensor.
	//
	// The ID is to be provided by the environment simulation, the sensor
	// model is not in a position to provide a useful default value.
	//
	SensorId *Identifier `protobuf:"bytes,1,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// The physical mounting position of the sensor (origin and orientation
	// of the sensor coordinate system) given in vehicle coordinates [1].
	// The physical position pertains to this detector individually, and
	// governs the sensor-relative coordinates in features detected by this
	// detector.
	//
	// \arg \b x-direction of sensor coordinate system: sensor viewing direction
	// \arg \b z-direction of sensor coordinate system: sensor (up)
	// \arg \b y-direction of sensor coordinate system: perpendicular to x and z
	// right hand system
	//
	// \par References:
	// - [1] DIN ISO 8855:2013-11
	//
	// \note The origin of vehicle's coordinate system in world frame is
	// ( \c MovingObject::base . \c BaseMoving::position +
	// Inverse_Rotation_yaw_pitch_roll( \c MovingObject::base . \c
	// BaseMoving::orientation) * \c
	// MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
	// the vehicle's coordinate system is equal to the orientation of the
	// vehicle's bounding box \c MovingObject::base . \c
	// BaseMoving::orientation. \note A default position can be provided by the
	// sensor model (e.g. to indicate the position the model was validated for),
	// but this is optional; the environment simulation must provide a valid
	// mounting position (based on the vehicle configuration) when setting the
	// view configuration.
	//
	MountingPosition *MountingPosition `protobuf:"bytes,2,opt,name=mounting_position,json=mountingPosition,proto3" json:"mounting_position,omitempty"`
	// The root mean squared error of the mounting position.
	//
	MountingPositionRmse *MountingPosition `protobuf:"bytes,3,opt,name=mounting_position_rmse,json=mountingPositionRmse,proto3" json:"mounting_position_rmse,omitempty"`
	// Field of View in horizontal orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_horizontal/2,  \c
	// #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \c
	// Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewHorizontal float64 `protobuf:"fixed64,4,opt,name=field_of_view_horizontal,json=fieldOfViewHorizontal,proto3" json:"field_of_view_horizontal,omitempty"`
	// Field of View in vertical orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_vertical/2,  \c
	// #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
	// as defined in \c Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewVertical float64 `protobuf:"fixed64,5,opt,name=field_of_view_vertical,json=fieldOfViewVertical,proto3" json:"field_of_view_vertical,omitempty"`
	// Number of rays to cast across horizontal field of view (azimuth).
	//
	// \note This is a characteristic of the ray tracing engine of the
	// environment simulation, not a direct characteristic of the sensor.
	NumberOfRaysHorizontal uint32 `protobuf:"varint,6,opt,name=number_of_rays_horizontal,json=numberOfRaysHorizontal,proto3" json:"number_of_rays_horizontal,omitempty"`
	// Number of rays to cast across vertical field of view (elevation).
	//
	// \note This is a characteristic of the ray tracing engine of the
	// environment simulation, not a direct characteristic of the sensor.
	NumberOfRaysVertical uint32 `protobuf:"varint,7,opt,name=number_of_rays_vertical,json=numberOfRaysVertical,proto3" json:"number_of_rays_vertical,omitempty"`
	// Maximum number of interactions to take into account.
	//
	// \note This is a characteristic of the ray tracing engine of the
	// environment simulation, not a direct characteristic of the sensor.
	MaxNumberOfInteractions uint32 `protobuf:"varint,8,opt,name=max_number_of_interactions,json=maxNumberOfInteractions,proto3" json:"max_number_of_interactions,omitempty"`
	// Emitter Frequency.
	//
	// This information can be used by a ray tracing engine to calculate
	// doppler shift information and take into account differences in
	// refraction and reflection. For doppler shift calculations the
	// sensor model can of course always provide a nominal frequency and
	// adjust the resulting doppler shift information to actual frequency
	// through frequency adjustments. For material and geometry interaction
	// purposes the frequency is also relevant.
	//
	// Unit: [Hz]
	EmitterFrequency float64 `protobuf:"fixed64,9,opt,name=emitter_frequency,json=emitterFrequency,proto3" json:"emitter_frequency,omitempty"`
	// This represents the TX antenna diagram
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	TxAntennaDiagram []*RadarSensorViewConfiguration_AntennaDiagramEntry `protobuf:"bytes,10,rep,name=tx_antenna_diagram,json=txAntennaDiagram,proto3" json:"tx_antenna_diagram,omitempty"`
	// This represents the RX antenna diagram
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	RxAntennaDiagram     []*RadarSensorViewConfiguration_AntennaDiagramEntry `protobuf:"bytes,11,rep,name=rx_antenna_diagram,json=rxAntennaDiagram,proto3" json:"rx_antenna_diagram,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                            `json:"-"`
	XXX_unrecognized     []byte                                              `json:"-"`
	XXX_sizecache        int32                                               `json:"-"`
}

func (m *RadarSensorViewConfiguration) Reset()         { *m = RadarSensorViewConfiguration{} }
func (m *RadarSensorViewConfiguration) String() string { return proto.CompactTextString(m) }
func (*RadarSensorViewConfiguration) ProtoMessage()    {}
func (*RadarSensorViewConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{2}
}

func (m *RadarSensorViewConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RadarSensorViewConfiguration.Unmarshal(m, b)
}
func (m *RadarSensorViewConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RadarSensorViewConfiguration.Marshal(b, m, deterministic)
}
func (m *RadarSensorViewConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadarSensorViewConfiguration.Merge(m, src)
}
func (m *RadarSensorViewConfiguration) XXX_Size() int {
	return xxx_messageInfo_RadarSensorViewConfiguration.Size(m)
}
func (m *RadarSensorViewConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_RadarSensorViewConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_RadarSensorViewConfiguration proto.InternalMessageInfo

func (m *RadarSensorViewConfiguration) GetSensorId() *Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

func (m *RadarSensorViewConfiguration) GetMountingPosition() *MountingPosition {
	if m != nil {
		return m.MountingPosition
	}
	return nil
}

func (m *RadarSensorViewConfiguration) GetMountingPositionRmse() *MountingPosition {
	if m != nil {
		return m.MountingPositionRmse
	}
	return nil
}

func (m *RadarSensorViewConfiguration) GetFieldOfViewHorizontal() float64 {
	if m != nil {
		return m.FieldOfViewHorizontal
	}
	return 0
}

func (m *RadarSensorViewConfiguration) GetFieldOfViewVertical() float64 {
	if m != nil {
		return m.FieldOfViewVertical
	}
	return 0
}

func (m *RadarSensorViewConfiguration) GetNumberOfRaysHorizontal() uint32 {
	if m != nil {
		return m.NumberOfRaysHorizontal
	}
	return 0
}

func (m *RadarSensorViewConfiguration) GetNumberOfRaysVertical() uint32 {
	if m != nil {
		return m.NumberOfRaysVertical
	}
	return 0
}

func (m *RadarSensorViewConfiguration) GetMaxNumberOfInteractions() uint32 {
	if m != nil {
		return m.MaxNumberOfInteractions
	}
	return 0
}

func (m *RadarSensorViewConfiguration) GetEmitterFrequency() float64 {
	if m != nil {
		return m.EmitterFrequency
	}
	return 0
}

func (m *RadarSensorViewConfiguration) GetTxAntennaDiagram() []*RadarSensorViewConfiguration_AntennaDiagramEntry {
	if m != nil {
		return m.TxAntennaDiagram
	}
	return nil
}

func (m *RadarSensorViewConfiguration) GetRxAntennaDiagram() []*RadarSensorViewConfiguration_AntennaDiagramEntry {
	if m != nil {
		return m.RxAntennaDiagram
	}
	return nil
}

//
// \brief The radar antenna diagram.
//
// \note Rotation is defined analog Spherical3d
type RadarSensorViewConfiguration_AntennaDiagramEntry struct {
	// Horizontal deflection (azimuth) of entry in sensor/antenna
	// coordinates.
	//
	// Unit: [rad]
	HorizontalAngle float64 `protobuf:"fixed64,1,opt,name=horizontal_angle,json=horizontalAngle,proto3" json:"horizontal_angle,omitempty"`
	// Vertical deflection (elevation) of entry in sensor/antenna
	// coordinates.
	//
	// Unit: [rad]
	VerticalAngle float64 `protobuf:"fixed64,2,opt,name=vertical_angle,json=verticalAngle,proto3" json:"vertical_angle,omitempty"`
	// Response of antenna at this point (positive dB is gain,
	// negative dB is attenuation).
	//
	// Unit: [dB]
	Response             float64  `protobuf:"fixed64,3,opt,name=response,proto3" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) Reset() {
	*m = RadarSensorViewConfiguration_AntennaDiagramEntry{}
}
func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) String() string {
	return proto.CompactTextString(m)
}
func (*RadarSensorViewConfiguration_AntennaDiagramEntry) ProtoMessage() {}
func (*RadarSensorViewConfiguration_AntennaDiagramEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{2, 0}
}

func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RadarSensorViewConfiguration_AntennaDiagramEntry.Unmarshal(m, b)
}
func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RadarSensorViewConfiguration_AntennaDiagramEntry.Marshal(b, m, deterministic)
}
func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadarSensorViewConfiguration_AntennaDiagramEntry.Merge(m, src)
}
func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) XXX_Size() int {
	return xxx_messageInfo_RadarSensorViewConfiguration_AntennaDiagramEntry.Size(m)
}
func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RadarSensorViewConfiguration_AntennaDiagramEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RadarSensorViewConfiguration_AntennaDiagramEntry proto.InternalMessageInfo

func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) GetHorizontalAngle() float64 {
	if m != nil {
		return m.HorizontalAngle
	}
	return 0
}

func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) GetVerticalAngle() float64 {
	if m != nil {
		return m.VerticalAngle
	}
	return 0
}

func (m *RadarSensorViewConfiguration_AntennaDiagramEntry) GetResponse() float64 {
	if m != nil {
		return m.Response
	}
	return 0
}

//
// \brief The configuration settings for the Lidar Sensor View to be provided
// by the environment simulation.
//
type LidarSensorViewConfiguration struct {
	// The ID of the sensor at host vehicle's mounting_position.
	//
	// This is the ID of the physical sensor, to be used in its detected
	// features output; it is distinct from the ID of its virtual sensor.
	//
	// The ID is to be provided by the environment simulation, the sensor
	// model is not in a position to provide a useful default value.
	//
	SensorId *Identifier `protobuf:"bytes,1,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// The physical mounting position of the sensor (origin and orientation
	// of the sensor coordinate system) given in vehicle coordinates [1].
	// The physical position pertains to this detector individually, and
	// governs the sensor-relative coordinates in features detected by this
	// detector.
	//
	// \arg \b x-direction of sensor coordinate system: sensor viewing direction
	// \arg \b z-direction of sensor coordinate system: sensor (up)
	// \arg \b y-direction of sensor coordinate system: perpendicular to x and z
	// right hand system
	//
	// \par References:
	// - [1] DIN ISO 8855:2013-11
	//
	// \note The origin of vehicle's coordinate system in world frame is
	// ( \c MovingObject::base . \c BaseMoving::position +
	// Inverse_Rotation_yaw_pitch_roll( \c MovingObject::base . \c
	// BaseMoving::orientation) * \c
	// MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
	// the vehicle's coordinate system is equal to the orientation of the
	// vehicle's bounding box \c MovingObject::base . \c
	// BaseMoving::orientation. \note A default position can be provided by the
	// sensor model (e.g. to indicate the position the model was validated for),
	// but this is optional; the environment simulation must provide a valid
	// mounting position (based on the vehicle configuration) when setting the
	// view configuration.
	//
	MountingPosition *MountingPosition `protobuf:"bytes,2,opt,name=mounting_position,json=mountingPosition,proto3" json:"mounting_position,omitempty"`
	// The root mean squared error of the mounting position.
	//
	MountingPositionRmse *MountingPosition `protobuf:"bytes,3,opt,name=mounting_position_rmse,json=mountingPositionRmse,proto3" json:"mounting_position_rmse,omitempty"`
	// Field of View in horizontal orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_horizontal/2,  \c
	// #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \c
	// Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewHorizontal float64 `protobuf:"fixed64,4,opt,name=field_of_view_horizontal,json=fieldOfViewHorizontal,proto3" json:"field_of_view_horizontal,omitempty"`
	// Field of View in vertical orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_vertical/2,  \c
	// #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
	// as defined in \c Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewVertical float64 `protobuf:"fixed64,5,opt,name=field_of_view_vertical,json=fieldOfViewVertical,proto3" json:"field_of_view_vertical,omitempty"`
	// Number of rays to cast across horizontal field of view.
	//
	// \note This is a characteristic of the ray tracing engine of the
	// environment simulation, not a direct characteristic of the sensor.
	NumberOfRaysHorizontal uint32 `protobuf:"varint,6,opt,name=number_of_rays_horizontal,json=numberOfRaysHorizontal,proto3" json:"number_of_rays_horizontal,omitempty"`
	// Number of rays to cast across vertical field of view.
	//
	// \note This is a characteristic of the ray tracing engine of the
	// environment simulation, not a direct characteristic of the sensor.
	NumberOfRaysVertical uint32 `protobuf:"varint,7,opt,name=number_of_rays_vertical,json=numberOfRaysVertical,proto3" json:"number_of_rays_vertical,omitempty"`
	// Maximum number of interactions to take into account.
	//
	// \note This is a characteristic of the ray tracing engine of the
	// environment simulation, not a direct characteristic of the sensor.
	MaxNumberOfInteractions uint32 `protobuf:"varint,8,opt,name=max_number_of_interactions,json=maxNumberOfInteractions,proto3" json:"max_number_of_interactions,omitempty"`
	// Emitter Frequency.
	//
	// This information can be used by a ray tracing engine to calculate
	// doppler shift information and take into account differences in
	// refraction and reflection. For doppler shift calculations the
	// sensor model can of course always provide a nominal frequency and
	// adjust the resulting doppler shift information to actual frequency
	// through frequency adjustments. For material and geometry interaction
	// purposes the frequency is also relevant.
	//
	// Unit: [Hz]
	EmitterFrequency float64 `protobuf:"fixed64,9,opt,name=emitter_frequency,json=emitterFrequency,proto3" json:"emitter_frequency,omitempty"`
	// Number of pixels in frame.
	//
	// This field includes the number of pixels in each frame
	//
	NumOfPixels uint32 `protobuf:"varint,10,opt,name=num_of_pixels,json=numOfPixels,proto3" json:"num_of_pixels,omitempty"`
	// Ray tracing data.
	//
	// The directions unit vectors describing the Lidar's raster transmission directions.
	// Length is num_of_pixels
	// \note data is in Lidar's coordinate system
	//
	Directions []*Vector3D `protobuf:"bytes,11,rep,name=directions,proto3" json:"directions,omitempty"`
	// Ray tracing data.
	//
	// The time offset in microseconds of every measurement from each frame timestamp.
	// Length is num_of_pixels
	//
	Timings              []uint32 `protobuf:"varint,12,rep,packed,name=timings,proto3" json:"timings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LidarSensorViewConfiguration) Reset()         { *m = LidarSensorViewConfiguration{} }
func (m *LidarSensorViewConfiguration) String() string { return proto.CompactTextString(m) }
func (*LidarSensorViewConfiguration) ProtoMessage()    {}
func (*LidarSensorViewConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{3}
}

func (m *LidarSensorViewConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LidarSensorViewConfiguration.Unmarshal(m, b)
}
func (m *LidarSensorViewConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LidarSensorViewConfiguration.Marshal(b, m, deterministic)
}
func (m *LidarSensorViewConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LidarSensorViewConfiguration.Merge(m, src)
}
func (m *LidarSensorViewConfiguration) XXX_Size() int {
	return xxx_messageInfo_LidarSensorViewConfiguration.Size(m)
}
func (m *LidarSensorViewConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_LidarSensorViewConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_LidarSensorViewConfiguration proto.InternalMessageInfo

func (m *LidarSensorViewConfiguration) GetSensorId() *Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

func (m *LidarSensorViewConfiguration) GetMountingPosition() *MountingPosition {
	if m != nil {
		return m.MountingPosition
	}
	return nil
}

func (m *LidarSensorViewConfiguration) GetMountingPositionRmse() *MountingPosition {
	if m != nil {
		return m.MountingPositionRmse
	}
	return nil
}

func (m *LidarSensorViewConfiguration) GetFieldOfViewHorizontal() float64 {
	if m != nil {
		return m.FieldOfViewHorizontal
	}
	return 0
}

func (m *LidarSensorViewConfiguration) GetFieldOfViewVertical() float64 {
	if m != nil {
		return m.FieldOfViewVertical
	}
	return 0
}

func (m *LidarSensorViewConfiguration) GetNumberOfRaysHorizontal() uint32 {
	if m != nil {
		return m.NumberOfRaysHorizontal
	}
	return 0
}

func (m *LidarSensorViewConfiguration) GetNumberOfRaysVertical() uint32 {
	if m != nil {
		return m.NumberOfRaysVertical
	}
	return 0
}

func (m *LidarSensorViewConfiguration) GetMaxNumberOfInteractions() uint32 {
	if m != nil {
		return m.MaxNumberOfInteractions
	}
	return 0
}

func (m *LidarSensorViewConfiguration) GetEmitterFrequency() float64 {
	if m != nil {
		return m.EmitterFrequency
	}
	return 0
}

func (m *LidarSensorViewConfiguration) GetNumOfPixels() uint32 {
	if m != nil {
		return m.NumOfPixels
	}
	return 0
}

func (m *LidarSensorViewConfiguration) GetDirections() []*Vector3D {
	if m != nil {
		return m.Directions
	}
	return nil
}

func (m *LidarSensorViewConfiguration) GetTimings() []uint32 {
	if m != nil {
		return m.Timings
	}
	return nil
}

//
// \brief The configuration settings for the Camera Sensor View to be provided
// by the environment simulation.
//
type CameraSensorViewConfiguration struct {
	// The ID of the sensor at host vehicle's mounting_position.
	//
	// This is the ID of the physical sensor, to be used in its detected
	// features output; it is distinct from the ID of its virtual sensor.
	//
	// The ID is to be provided by the environment simulation, the sensor
	// model is not in a position to provide a useful default value.
	//
	SensorId *Identifier `protobuf:"bytes,1,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// The physical mounting position of the sensor (origin and orientation
	// of the sensor coordinate system) given in vehicle coordinates [1].
	// The physical position pertains to this detector individually, and
	// governs the sensor-relative coordinates in features detected by this
	// detector.
	//
	// \arg \b x-direction of sensor coordinate system: sensor viewing direction
	// \arg \b z-direction of sensor coordinate system: sensor (up)
	// \arg \b y-direction of sensor coordinate system: perpendicular to x and z
	// right hand system
	//
	// \par References:
	// - [1] DIN ISO 8855:2013-11
	//
	// \note The origin of vehicle's coordinate system in world frame is
	// ( \c MovingObject::base . \c BaseMoving::position +
	// Inverse_Rotation_yaw_pitch_roll( \c MovingObject::base . \c
	// BaseMoving::orientation) * \c
	// MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
	// the vehicle's coordinate system is equal to the orientation of the
	// vehicle's bounding box \c MovingObject::base . \c
	// BaseMoving::orientation. \note A default position can be provided by the
	// sensor model (e.g. to indicate the position the model was validated for),
	// but this is optional; the environment simulation must provide a valid
	// mounting position (based on the vehicle configuration) when setting the
	// view configuration.
	//
	MountingPosition *MountingPosition `protobuf:"bytes,2,opt,name=mounting_position,json=mountingPosition,proto3" json:"mounting_position,omitempty"`
	// The root mean squared error of the mounting position.
	//
	MountingPositionRmse *MountingPosition `protobuf:"bytes,3,opt,name=mounting_position_rmse,json=mountingPositionRmse,proto3" json:"mounting_position_rmse,omitempty"`
	// Field of View in horizontal orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_horizontal/2,  \c
	// #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \c
	// Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewHorizontal float64 `protobuf:"fixed64,4,opt,name=field_of_view_horizontal,json=fieldOfViewHorizontal,proto3" json:"field_of_view_horizontal,omitempty"`
	// Field of View in vertical orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_vertical/2,  \c
	// #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
	// as defined in \c Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewVertical float64 `protobuf:"fixed64,5,opt,name=field_of_view_vertical,json=fieldOfViewVertical,proto3" json:"field_of_view_vertical,omitempty"`
	// Number of pixels to produce across horizontal field of view.
	//
	// \note This is a characteristic of the rendering engine of the
	// environment simulation, not a direct characteristic of the sensor.
	NumberOfPixelsHorizontal uint32 `protobuf:"varint,6,opt,name=number_of_pixels_horizontal,json=numberOfPixelsHorizontal,proto3" json:"number_of_pixels_horizontal,omitempty"`
	// Number of pixels to produce across horizontal field of view.
	//
	// \note This is a characteristic of the rendering engine of the
	// environment simulation, not a direct characteristic of the sensor.
	NumberOfPixelsVertical uint32 `protobuf:"varint,7,opt,name=number_of_pixels_vertical,json=numberOfPixelsVertical,proto3" json:"number_of_pixels_vertical,omitempty"`
	// Format for image data (includes number, kind and format of channels).
	//
	// In the message provided by the sensor model, this field can
	// be repeated and all values are acceptable to the model, with
	// the most acceptable value being listed first, and the remaining
	// values indicating alternatives in descending order of preference.
	//
	// In the message provided to the sensor model, this field must
	// contain exactly one value, indicating the format of the image
	// data being provided by the simulation environment - which must
	// be one of the values the sensor model requested - or there
	// must be no value, indicating that the simulation environment
	// cannot provide image data in one of the requested formats.
	//
	ChannelFormat        []CameraSensorViewConfiguration_ChannelFormat `protobuf:"varint,8,rep,packed,name=channel_format,json=channelFormat,proto3,enum=osi3.CameraSensorViewConfiguration_ChannelFormat" json:"channel_format,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *CameraSensorViewConfiguration) Reset()         { *m = CameraSensorViewConfiguration{} }
func (m *CameraSensorViewConfiguration) String() string { return proto.CompactTextString(m) }
func (*CameraSensorViewConfiguration) ProtoMessage()    {}
func (*CameraSensorViewConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{4}
}

func (m *CameraSensorViewConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CameraSensorViewConfiguration.Unmarshal(m, b)
}
func (m *CameraSensorViewConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CameraSensorViewConfiguration.Marshal(b, m, deterministic)
}
func (m *CameraSensorViewConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CameraSensorViewConfiguration.Merge(m, src)
}
func (m *CameraSensorViewConfiguration) XXX_Size() int {
	return xxx_messageInfo_CameraSensorViewConfiguration.Size(m)
}
func (m *CameraSensorViewConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_CameraSensorViewConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_CameraSensorViewConfiguration proto.InternalMessageInfo

func (m *CameraSensorViewConfiguration) GetSensorId() *Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

func (m *CameraSensorViewConfiguration) GetMountingPosition() *MountingPosition {
	if m != nil {
		return m.MountingPosition
	}
	return nil
}

func (m *CameraSensorViewConfiguration) GetMountingPositionRmse() *MountingPosition {
	if m != nil {
		return m.MountingPositionRmse
	}
	return nil
}

func (m *CameraSensorViewConfiguration) GetFieldOfViewHorizontal() float64 {
	if m != nil {
		return m.FieldOfViewHorizontal
	}
	return 0
}

func (m *CameraSensorViewConfiguration) GetFieldOfViewVertical() float64 {
	if m != nil {
		return m.FieldOfViewVertical
	}
	return 0
}

func (m *CameraSensorViewConfiguration) GetNumberOfPixelsHorizontal() uint32 {
	if m != nil {
		return m.NumberOfPixelsHorizontal
	}
	return 0
}

func (m *CameraSensorViewConfiguration) GetNumberOfPixelsVertical() uint32 {
	if m != nil {
		return m.NumberOfPixelsVertical
	}
	return 0
}

func (m *CameraSensorViewConfiguration) GetChannelFormat() []CameraSensorViewConfiguration_ChannelFormat {
	if m != nil {
		return m.ChannelFormat
	}
	return nil
}

//
// \brief The configuration settings for the Ultrasonic Sensor View to be
// provided by the environment simulation.
//
type UltrasonicSensorViewConfiguration struct {
	// The ID of the sensor at host vehicle's mounting_position.
	//
	// This is the ID of the physical sensor, to be used in its detected
	// features output; it is distinct from the ID of its virtual sensor.
	//
	// The ID is to be provided by the environment simulation, the sensor
	// model is not in a position to provide a useful default value.
	//
	SensorId *Identifier `protobuf:"bytes,1,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	// The physical mounting position of the sensor (origin and orientation
	// of the sensor coordinate system) given in vehicle coordinates [1].
	// The physical position pertains to this detector individually, and
	// governs the sensor-relative coordinates in features detected by this
	// detector.
	//
	// \arg \b x-direction of sensor coordinate system: sensor viewing direction
	// \arg \b z-direction of sensor coordinate system: sensor (up)
	// \arg \b y-direction of sensor coordinate system: perpendicular to x and z
	// right hand system
	//
	// \par References:
	// - [1] DIN ISO 8855:2013-11
	//
	// \note The origin of vehicle's coordinate system in world frame is
	// ( \c MovingObject::base . \c BaseMoving::position +
	// Inverse_Rotation_yaw_pitch_roll( \c MovingObject::base . \c
	// BaseMoving::orientation) * \c
	// MovingObject::VehicleAttributes::bbcenter_to_rear) . The orientation of
	// the vehicle's coordinate system is equal to the orientation of the
	// vehicle's bounding box \c MovingObject::base . \c
	// BaseMoving::orientation. \note A default position can be provided by the
	// sensor model (e.g. to indicate the position the model was validated for),
	// but this is optional; the environment simulation must provide a valid
	// mounting position (based on the vehicle configuration) when setting the
	// view configuration.
	//
	MountingPosition *MountingPosition `protobuf:"bytes,2,opt,name=mounting_position,json=mountingPosition,proto3" json:"mounting_position,omitempty"`
	// The root mean squared error of the mounting position.
	//
	MountingPositionRmse *MountingPosition `protobuf:"bytes,3,opt,name=mounting_position_rmse,json=mountingPositionRmse,proto3" json:"mounting_position_rmse,omitempty"`
	// Field of View in horizontal orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_horizontal/2,  \c
	// #field_of_view_horizontal/2] azimuth in the sensor frame as defined in \c
	// Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewHorizontal float64 `protobuf:"fixed64,4,opt,name=field_of_view_horizontal,json=fieldOfViewHorizontal,proto3" json:"field_of_view_horizontal,omitempty"`
	// Field of View in vertical orientation of the physical sensor.
	//
	// Viewing range: [- \c #field_of_view_vertical/2,  \c
	// #field_of_view_vertical/2] elevation in the sensor frame at zero azimuth
	// as defined in \c Spherical3d.
	//
	// Unit: [rad]
	FieldOfViewVertical  float64  `protobuf:"fixed64,5,opt,name=field_of_view_vertical,json=fieldOfViewVertical,proto3" json:"field_of_view_vertical,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UltrasonicSensorViewConfiguration) Reset()         { *m = UltrasonicSensorViewConfiguration{} }
func (m *UltrasonicSensorViewConfiguration) String() string { return proto.CompactTextString(m) }
func (*UltrasonicSensorViewConfiguration) ProtoMessage()    {}
func (*UltrasonicSensorViewConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_979af0ca68024fea, []int{5}
}

func (m *UltrasonicSensorViewConfiguration) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UltrasonicSensorViewConfiguration.Unmarshal(m, b)
}
func (m *UltrasonicSensorViewConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UltrasonicSensorViewConfiguration.Marshal(b, m, deterministic)
}
func (m *UltrasonicSensorViewConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UltrasonicSensorViewConfiguration.Merge(m, src)
}
func (m *UltrasonicSensorViewConfiguration) XXX_Size() int {
	return xxx_messageInfo_UltrasonicSensorViewConfiguration.Size(m)
}
func (m *UltrasonicSensorViewConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_UltrasonicSensorViewConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_UltrasonicSensorViewConfiguration proto.InternalMessageInfo

func (m *UltrasonicSensorViewConfiguration) GetSensorId() *Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

func (m *UltrasonicSensorViewConfiguration) GetMountingPosition() *MountingPosition {
	if m != nil {
		return m.MountingPosition
	}
	return nil
}

func (m *UltrasonicSensorViewConfiguration) GetMountingPositionRmse() *MountingPosition {
	if m != nil {
		return m.MountingPositionRmse
	}
	return nil
}

func (m *UltrasonicSensorViewConfiguration) GetFieldOfViewHorizontal() float64 {
	if m != nil {
		return m.FieldOfViewHorizontal
	}
	return 0
}

func (m *UltrasonicSensorViewConfiguration) GetFieldOfViewVertical() float64 {
	if m != nil {
		return m.FieldOfViewVertical
	}
	return 0
}

func init() {
	proto.RegisterEnum("osi3.CameraSensorViewConfiguration_ChannelFormat", CameraSensorViewConfiguration_ChannelFormat_name, CameraSensorViewConfiguration_ChannelFormat_value)
	proto.RegisterType((*SensorViewConfiguration)(nil), "osi3.SensorViewConfiguration")
	proto.RegisterType((*GenericSensorViewConfiguration)(nil), "osi3.GenericSensorViewConfiguration")
	proto.RegisterType((*RadarSensorViewConfiguration)(nil), "osi3.RadarSensorViewConfiguration")
	proto.RegisterType((*RadarSensorViewConfiguration_AntennaDiagramEntry)(nil), "osi3.RadarSensorViewConfiguration.AntennaDiagramEntry")
	proto.RegisterType((*LidarSensorViewConfiguration)(nil), "osi3.LidarSensorViewConfiguration")
	proto.RegisterType((*CameraSensorViewConfiguration)(nil), "osi3.CameraSensorViewConfiguration")
	proto.RegisterType((*UltrasonicSensorViewConfiguration)(nil), "osi3.UltrasonicSensorViewConfiguration")
}

func init() { proto.RegisterFile("osi_sensorviewconfiguration.proto", fileDescriptor_979af0ca68024fea) }

var fileDescriptor_979af0ca68024fea = []byte{
	// 1079 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xdf, 0x4e, 0x1b, 0xc7,
	0x17, 0xfe, 0xd9, 0x06, 0x6c, 0x0e, 0x31, 0x98, 0x81, 0x98, 0x8d, 0x03, 0xc4, 0xf8, 0x47, 0x54,
	0xaa, 0xaa, 0x56, 0x03, 0x6a, 0xda, 0x2a, 0xaa, 0x2a, 0x70, 0xf9, 0xa7, 0x82, 0x1d, 0x4d, 0x80,
	0xb6, 0x57, 0xab, 0xc9, 0x7a, 0xd6, 0x99, 0x6a, 0x67, 0xd6, 0x9d, 0x1d, 0x13, 0xdc, 0xdb, 0xde,
	0xe4, 0x11, 0xfa, 0x58, 0x95, 0xfa, 0x06, 0xbd, 0xea, 0xbf, 0x47, 0xe8, 0x45, 0xb5, 0x33, 0xbb,
	0x66, 0x6d, 0xf0, 0x52, 0xd2, 0x5c, 0x72, 0x39, 0xe7, 0xfb, 0xbe, 0xf3, 0x1d, 0xcf, 0x9c, 0x39,
	0x3b, 0x32, 0xac, 0xf9, 0x01, 0xb3, 0x03, 0x2a, 0x02, 0x5f, 0x9e, 0x33, 0xfa, 0xda, 0xf1, 0x85,
	0xcb, 0x3a, 0x3d, 0x49, 0x14, 0xf3, 0x45, 0xbd, 0x2b, 0x7d, 0xe5, 0xa3, 0x09, 0x3f, 0x60, 0x5b,
	0x95, 0x52, 0x48, 0x74, 0x7c, 0xce, 0xe3, 0x78, 0x65, 0x3e, 0x8c, 0x9c, 0x53, 0x19, 0x0c, 0xa8,
	0xb5, 0x37, 0xd3, 0xb0, 0xf4, 0x42, 0x27, 0x3b, 0x63, 0xf4, 0x75, 0x23, 0x99, 0x0c, 0x7d, 0x04,
	0xf9, 0x88, 0x6c, 0x65, 0xaa, 0x99, 0x8d, 0x99, 0xcd, 0x72, 0x3d, 0x4c, 0x5c, 0x3f, 0x14, 0x8a,
	0x4a, 0x97, 0x38, 0xf4, 0xcc, 0xa0, 0x38, 0xa6, 0xa1, 0x0f, 0x61, 0xda, 0x54, 0x66, 0xb3, 0xb6,
	0x95, 0xd5, 0x9a, 0x52, 0xa4, 0x69, 0x53, 0xa1, 0x98, 0xcb, 0xa8, 0xc4, 0x05, 0x43, 0x39, 0x6c,
	0xa3, 0x06, 0xcc, 0x73, 0xbf, 0x27, 0x14, 0x13, 0x1d, 0xbb, 0xeb, 0x07, 0x2c, 0x74, 0xb5, 0x72,
	0x49, 0xab, 0xe3, 0x08, 0x7e, 0x1e, 0xa1, 0xb8, 0xc4, 0x47, 0x22, 0xe8, 0x08, 0xca, 0x57, 0x92,
	0xd8, 0x92, 0x07, 0xd4, 0x9a, 0x48, 0xcd, 0xb4, 0x38, 0x9a, 0x09, 0xf3, 0x80, 0xa2, 0x4f, 0xc0,
	0x72, 0x19, 0xf5, 0xda, 0xb6, 0xef, 0xda, 0xe1, 0xf6, 0xda, 0xaf, 0x7c, 0xc9, 0x7e, 0xf0, 0x85,
	0x22, 0x9e, 0x35, 0x59, 0xcd, 0x6c, 0x64, 0xf0, 0x7d, 0x8d, 0xb7, 0xdc, 0x70, 0xbf, 0x0e, 0x06,
	0x20, 0xda, 0x82, 0xf2, 0xb0, 0xf0, 0x9c, 0x4a, 0xc5, 0x1c, 0xe2, 0x59, 0x53, 0x5a, 0xb6, 0x90,
	0x90, 0x9d, 0x45, 0x10, 0x5a, 0x84, 0x49, 0x49, 0x44, 0x87, 0x5a, 0x79, 0xcd, 0x31, 0x0b, 0xf4,
	0x0c, 0xe6, 0x7b, 0xdd, 0x36, 0x51, 0xd4, 0x76, 0xfa, 0x8e, 0x47, 0x6d, 0xc5, 0x38, 0xb5, 0x0a,
	0xfa, 0xc7, 0xcc, 0x99, 0x1f, 0x73, 0xc2, 0x38, 0x0d, 0x14, 0xe1, 0x5d, 0x3c, 0x67, 0x98, 0x8d,
	0x90, 0x18, 0x46, 0xd1, 0x17, 0xb0, 0x30, 0x24, 0xf6, 0x5d, 0x37, 0xa0, 0xca, 0x9a, 0xbe, 0x5e,
	0x3e, 0x9f, 0x90, 0xb7, 0x34, 0x13, 0x35, 0xe0, 0x7e, 0xc0, 0x78, 0xcf, 0xd3, 0x3d, 0x60, 0x07,
	0x8a, 0x48, 0x65, 0x2a, 0x80, 0xeb, 0x53, 0x2c, 0x5c, 0xb2, 0x5f, 0x84, 0x64, 0x5d, 0x45, 0x17,
	0xd6, 0x3a, 0x54, 0x50, 0xc9, 0x9c, 0xa8, 0x55, 0xcd, 0x9e, 0x0c, 0x35, 0xab, 0xf5, 0x5b, 0xbe,
	0x9a, 0xdb, 0x98, 0xd9, 0x5c, 0x37, 0x19, 0xf7, 0x0d, 0x7f, 0x4c, 0x33, 0xe2, 0xd5, 0x4e, 0x2a,
	0x8e, 0xbe, 0x83, 0x47, 0x92, 0xb4, 0x89, 0x4c, 0xf1, 0xfb, 0xdd, 0xf8, 0xd5, 0x8c, 0x1f, 0x0e,
	0xd9, 0xe3, 0xdc, 0x96, 0x65, 0x0a, 0x1a, 0x7a, 0x79, 0x2c, 0xdd, 0xeb, 0x8f, 0x21, 0xaf, 0x23,
	0x96, 0xe6, 0xe5, 0xa5, 0xa0, 0x88, 0x43, 0xd5, 0x21, 0x9c, 0x4a, 0x92, 0x62, 0xf6, 0xa7, 0x31,
	0xfb, 0xbf, 0x31, 0x6b, 0x68, 0xfa, 0x38, 0xb7, 0x15, 0x27, 0x0d, 0x46, 0x7d, 0x58, 0xef, 0x79,
	0x4a, 0x92, 0xc0, 0x17, 0xa9, 0x67, 0xf7, 0x97, 0xb1, 0x7c, 0xcf, 0x58, 0x9e, 0x0e, 0x24, 0xe3,
	0x6c, 0xd7, 0x7a, 0x37, 0x51, 0x6a, 0x3f, 0x67, 0x61, 0x35, 0xbd, 0x09, 0x86, 0xe7, 0x4b, 0xe6,
	0xed, 0xe6, 0x4b, 0xf6, 0x9d, 0xcd, 0x97, 0xdc, 0x3b, 0x9e, 0x2f, 0x13, 0x6f, 0x37, 0x5f, 0x26,
	0xc7, 0xce, 0x97, 0xda, 0xdf, 0x53, 0xb0, 0x9c, 0xd6, 0xe7, 0x77, 0x1b, 0x7a, 0xbb, 0x0d, 0x45,
	0x9f, 0xc1, 0x03, 0xd1, 0xe3, 0x2f, 0xa9, 0x0c, 0x55, 0x92, 0xf4, 0x83, 0xa4, 0x5d, 0x38, 0xe8,
	0x8b, 0xb8, 0x6c, 0x08, 0x2d, 0x17, 0x93, 0x7e, 0x90, 0xf0, 0xfb, 0x18, 0x96, 0x46, 0xa4, 0x03,
	0xc3, 0xbc, 0x16, 0x2e, 0x26, 0x85, 0x03, 0xc7, 0x67, 0x50, 0xe1, 0xe4, 0xc2, 0xbe, 0x94, 0xb2,
	0xf0, 0xeb, 0x4b, 0x9c, 0x70, 0x03, 0x02, 0xfd, 0x55, 0x28, 0xe2, 0x25, 0x4e, 0x2e, 0x9a, 0x91,
	0xf8, 0x30, 0x01, 0xa3, 0x0f, 0x60, 0x9e, 0x72, 0xa6, 0x14, 0x95, 0xb6, 0x2b, 0xe9, 0xf7, 0x3d,
	0x2a, 0x9c, 0xbe, 0xfe, 0x14, 0x64, 0x70, 0x29, 0x02, 0xf6, 0xe2, 0x38, 0x6a, 0x03, 0x52, 0x17,
	0x36, 0x11, 0x8a, 0x0a, 0x41, 0xec, 0x36, 0x23, 0x1d, 0x49, 0xb8, 0x05, 0xfa, 0x9e, 0x3f, 0xbd,
	0x79, 0x66, 0xd6, 0xb7, 0x8d, 0xf2, 0x4b, 0x23, 0xdc, 0x15, 0x4a, 0xf6, 0x71, 0x49, 0x5d, 0x0c,
	0x87, 0x43, 0x17, 0x79, 0xd5, 0x65, 0xe6, 0xbf, 0xb9, 0xc8, 0x11, 0x97, 0xca, 0x8f, 0x19, 0x58,
	0xb8, 0x86, 0x89, 0xde, 0x87, 0xd2, 0xe5, 0x81, 0xd9, 0x44, 0x74, 0x3c, 0xaa, 0xdb, 0x3e, 0x83,
	0xe7, 0x2e, 0xe3, 0xdb, 0x61, 0x18, 0x3d, 0x86, 0xd9, 0xf8, 0x80, 0x22, 0x62, 0x56, 0x13, 0x8b,
	0x71, 0xd4, 0xd0, 0x2a, 0x50, 0x90, 0x34, 0xe8, 0xfa, 0x22, 0xea, 0xdf, 0x0c, 0x1e, 0xac, 0x6b,
	0x3f, 0x4d, 0xc2, 0x72, 0xda, 0xe8, 0xbf, 0xbb, 0x7e, 0x77, 0xd7, 0x6f, 0x70, 0xfd, 0x6a, 0x50,
	0x14, 0x3d, 0x1e, 0x5a, 0x74, 0xd9, 0x05, 0xf5, 0x02, 0xfd, 0xde, 0x2a, 0xe2, 0x19, 0xd1, 0xe3,
	0x2d, 0xf7, 0xb9, 0x0e, 0xa1, 0x3a, 0x40, 0x9b, 0x49, 0x1a, 0xb9, 0x9b, 0x4b, 0x33, 0x6b, 0xce,
	0xeb, 0x8c, 0x3a, 0xca, 0x97, 0x5b, 0x6d, 0x9c, 0x60, 0x20, 0x0b, 0xf2, 0x8a, 0x71, 0x26, 0x3a,
	0x81, 0x75, 0xaf, 0x9a, 0xdb, 0x28, 0xe2, 0x78, 0x59, 0x7b, 0x53, 0x80, 0x95, 0xd4, 0x87, 0xc2,
	0x5d, 0x6f, 0xde, 0xb2, 0x37, 0x3f, 0x87, 0x87, 0x97, 0x5d, 0x62, 0x8e, 0xf0, 0x6a, 0x77, 0x5a,
	0x71, 0x93, 0x99, 0x03, 0x4d, 0x78, 0x0e, 0xb5, 0x76, 0x24, 0x1f, 0xe9, 0xd0, 0xf2, 0xb0, 0x78,
	0xe0, 0xfc, 0x0d, 0xcc, 0x3a, 0xaf, 0x88, 0x10, 0xd4, 0xb3, 0x5d, 0x5f, 0x72, 0xa2, 0xac, 0x42,
	0x35, 0xb7, 0x31, 0xbb, 0xf9, 0xe4, 0x5f, 0xbc, 0x07, 0xeb, 0x0d, 0xa3, 0xdc, 0xd3, 0x42, 0x5c,
	0x74, 0x92, 0xcb, 0xda, 0xaf, 0x39, 0x28, 0x0e, 0x11, 0x50, 0x05, 0xca, 0x8d, 0x83, 0xed, 0x66,
	0x73, 0xf7, 0xc8, 0xde, 0x6b, 0xe1, 0xe3, 0xed, 0x13, 0xfb, 0xb4, 0xf9, 0x55, 0xb3, 0xf5, 0x75,
	0xb3, 0xf4, 0x3f, 0x64, 0xc1, 0xe2, 0x08, 0xd6, 0x3a, 0x39, 0xd8, 0xc5, 0xa5, 0x0c, 0x5a, 0x85,
	0xca, 0x08, 0x72, 0xdc, 0x6a, 0xb6, 0xec, 0xd3, 0x4f, 0xed, 0xa3, 0xc3, 0x66, 0x29, 0x8b, 0x1e,
	0xc1, 0xc3, 0x6b, 0xf1, 0x27, 0x4f, 0x35, 0x21, 0x37, 0x96, 0xb0, 0xb5, 0xa9, 0x09, 0x13, 0xe3,
	0x08, 0x7b, 0x11, 0x61, 0x12, 0xad, 0xc0, 0x83, 0x11, 0x02, 0xde, 0xdf, 0x89, 0x2b, 0x98, 0xba,
	0xa6, 0x42, 0x0d, 0x47, 0x05, 0xe4, 0xc7, 0xe1, 0x51, 0xfa, 0xc2, 0x18, 0x3c, 0xb6, 0x9f, 0x46,
	0xeb, 0x50, 0x1d, 0xc1, 0x77, 0xb6, 0xbf, 0xdd, 0xc5, 0xf6, 0xce, 0xfe, 0x3e, 0x8e, 0xab, 0x00,
	0xf4, 0x18, 0xd6, 0x52, 0x58, 0x51, 0x31, 0x33, 0x37, 0xd0, 0x22, 0xcf, 0x7b, 0xe9, 0xb4, 0xb8,
	0xb4, 0x62, 0xed, 0x97, 0x2c, 0xac, 0xdd, 0xf8, 0x80, 0xbf, 0x1b, 0x07, 0xb7, 0x1b, 0x07, 0x3b,
	0xd9, 0x83, 0xcc, 0xcb, 0x29, 0xfd, 0x1f, 0xcb, 0xd6, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x31,
	0xa4, 0xae, 0x47, 0xb3, 0x11, 0x00, 0x00,
}
