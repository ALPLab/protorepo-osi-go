// Code generated by protoc-gen-go. DO NOT EDIT.
// source: osi_featuredata.proto

package osi3

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// Definition of a basic detection classifications.
//
type DetectionClassification int32

const (
	// Detection is unknown (must not be used in ground truth).
	//
	DetectionClassification_DETECTION_CLASSIFICATION_UNKNOWN DetectionClassification = 0
	// Other (unspecified but known) detection.
	//
	DetectionClassification_DETECTION_CLASSIFICATION_OTHER DetectionClassification = 1
	// Invalid detection, not to be used for object tracking, of unspecified
	// type (none of the other types applies).
	//
	DetectionClassification_DETECTION_CLASSIFICATION_INVALID DetectionClassification = 2
	// Clutter (noise, spray, rain, fog etc.).
	//
	DetectionClassification_DETECTION_CLASSIFICATION_CLUTTER DetectionClassification = 3
	// Over-drivable (ground etc.).
	//
	DetectionClassification_DETECTION_CLASSIFICATION_OVERDRIVABLE DetectionClassification = 4
	// Under-drivable (sign gantry etc.).
	//
	DetectionClassification_DETECTION_CLASSIFICATION_UNDERDRIVABLE DetectionClassification = 5
)

var DetectionClassification_name = map[int32]string{
	0: "DETECTION_CLASSIFICATION_UNKNOWN",
	1: "DETECTION_CLASSIFICATION_OTHER",
	2: "DETECTION_CLASSIFICATION_INVALID",
	3: "DETECTION_CLASSIFICATION_CLUTTER",
	4: "DETECTION_CLASSIFICATION_OVERDRIVABLE",
	5: "DETECTION_CLASSIFICATION_UNDERDRIVABLE",
}

var DetectionClassification_value = map[string]int32{
	"DETECTION_CLASSIFICATION_UNKNOWN":       0,
	"DETECTION_CLASSIFICATION_OTHER":         1,
	"DETECTION_CLASSIFICATION_INVALID":       2,
	"DETECTION_CLASSIFICATION_CLUTTER":       3,
	"DETECTION_CLASSIFICATION_OVERDRIVABLE":  4,
	"DETECTION_CLASSIFICATION_UNDERDRIVABLE": 5,
}

func (x DetectionClassification) String() string {
	return proto.EnumName(DetectionClassification_name, int32(x))
}

func (DetectionClassification) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{0}
}

//
// Data qualifier communicates the overall availability of the
// interface.
//
type SensorDetectionHeader_DataQualifier int32

const (
	// Unknown (must not be used in ground truth).
	//
	SensorDetectionHeader_DATA_QUALIFIER_UNKNOWN SensorDetectionHeader_DataQualifier = 0
	// Other (unspecified but known).
	//
	SensorDetectionHeader_DATA_QUALIFIER_OTHER SensorDetectionHeader_DataQualifier = 1
	// Data is available.
	//
	SensorDetectionHeader_DATA_QUALIFIER_AVAILABLE SensorDetectionHeader_DataQualifier = 2
	// Reduced data is available.
	//
	SensorDetectionHeader_DATA_QUALIFIER_AVAILABLE_REDUCED SensorDetectionHeader_DataQualifier = 3
	// Data is not available.
	//
	SensorDetectionHeader_DATA_QUALIFIER_NOT_AVAILABLE SensorDetectionHeader_DataQualifier = 4
	// Sensor is blind.
	//
	SensorDetectionHeader_DATA_QUALIFIER_BLINDNESS SensorDetectionHeader_DataQualifier = 5
	// Sensor temporary available.
	//
	SensorDetectionHeader_DATA_QUALIFIER_TEMPORARY_AVAILABLE SensorDetectionHeader_DataQualifier = 6
)

var SensorDetectionHeader_DataQualifier_name = map[int32]string{
	0: "DATA_QUALIFIER_UNKNOWN",
	1: "DATA_QUALIFIER_OTHER",
	2: "DATA_QUALIFIER_AVAILABLE",
	3: "DATA_QUALIFIER_AVAILABLE_REDUCED",
	4: "DATA_QUALIFIER_NOT_AVAILABLE",
	5: "DATA_QUALIFIER_BLINDNESS",
	6: "DATA_QUALIFIER_TEMPORARY_AVAILABLE",
}

var SensorDetectionHeader_DataQualifier_value = map[string]int32{
	"DATA_QUALIFIER_UNKNOWN":             0,
	"DATA_QUALIFIER_OTHER":               1,
	"DATA_QUALIFIER_AVAILABLE":           2,
	"DATA_QUALIFIER_AVAILABLE_REDUCED":   3,
	"DATA_QUALIFIER_NOT_AVAILABLE":       4,
	"DATA_QUALIFIER_BLINDNESS":           5,
	"DATA_QUALIFIER_TEMPORARY_AVAILABLE": 6,
}

func (x SensorDetectionHeader_DataQualifier) String() string {
	return proto.EnumName(SensorDetectionHeader_DataQualifier_name, int32(x))
}

func (SensorDetectionHeader_DataQualifier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{1, 0}
}

//
// \brief Interface for sensor data, in contrast to interpreted data after
// object hypothesis and tracking.
//
// All information regarding the environment is given with respect to the sensor
// coordinate system specified in \c SensorDetectionHeader::mounting_position.
// When simulating multiple sensors, each sensor has an individual copy of
// \c FeatureData in its own reference frame. This allows an independent
// treatment of the sensors.
//
type FeatureData struct {
	// The interface version used by the sender (i.e. the simulation
	// environment).
	//
	Version *InterfaceVersion `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Radar detections for multiple radar sensors (sensor fusion).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	RadarSensor []*RadarDetectionData `protobuf:"bytes,2,rep,name=radar_sensor,json=radarSensor,proto3" json:"radar_sensor,omitempty"`
	// Lidar detections for multiple lidar sensors (sensor fusion).
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	LidarSensor          []*LidarDetectionData `protobuf:"bytes,3,rep,name=lidar_sensor,json=lidarSensor,proto3" json:"lidar_sensor,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *FeatureData) Reset()         { *m = FeatureData{} }
func (m *FeatureData) String() string { return proto.CompactTextString(m) }
func (*FeatureData) ProtoMessage()    {}
func (*FeatureData) Descriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{0}
}

func (m *FeatureData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeatureData.Unmarshal(m, b)
}
func (m *FeatureData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeatureData.Marshal(b, m, deterministic)
}
func (m *FeatureData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureData.Merge(m, src)
}
func (m *FeatureData) XXX_Size() int {
	return xxx_messageInfo_FeatureData.Size(m)
}
func (m *FeatureData) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureData.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureData proto.InternalMessageInfo

func (m *FeatureData) GetVersion() *InterfaceVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *FeatureData) GetRadarSensor() []*RadarDetectionData {
	if m != nil {
		return m.RadarSensor
	}
	return nil
}

func (m *FeatureData) GetLidarSensor() []*LidarDetectionData {
	if m != nil {
		return m.LidarSensor
	}
	return nil
}

//
// \brief The header attributes of each sensor's detection list.
//
type SensorDetectionHeader struct {
	// Time stamp at which the measurement was taken (not the time at which it
	// was processed or at which it is transmitted) in the global synchronized
	// time.
	//
	// \note See \c SensorData::timestamp and
	// \c SensorData::last_measurement_time for detailed discussions on the
	// semantics of time-related fields.
	//
	MeasurementTime *Timestamp `protobuf:"bytes,1,opt,name=measurement_time,json=measurementTime,proto3" json:"measurement_time,omitempty"`
	// Monotonous counter to identify the exact cycle.
	// Generally the detection function is called periodic and
	// \c #cycle_counter corresponds to the number of periods.
	//
	CycleCounter uint64 `protobuf:"varint,2,opt,name=cycle_counter,json=cycleCounter,proto3" json:"cycle_counter,omitempty"`
	// Mounting position of the sensor (origin and orientation of the sensor
	// frame). Both origin and orientation are given in and with respect to the
	// host vehicle coordinate system (see: \c MovingObject::Vehicle vehicle
	// reference point) [1].
	//
	// The sensor frame's x-axis is pointing in the central viewing direction of
	// the sensor. It is the angle bisector of the sensor's horizontal and
	// vertical field of view. The terms horizontal and vertical must be
	// understood as names for the two principal planes of the sensor's field of
	// view (relative to the sensor frame's orientation), which do not have to
	// be horizontal or vertical in the strict sense of being parallel or
	// perpendicular to the local gravitational vector. The horizontal field
	// of view defines the sensor frame's xy-plane and the vertical field
	// of view defines the xz-plane. The sensor frame is right-handed and the
	// z-axis is pointing in an upward direction.
	//
	// The sensor frame uses cartesian coordinates. The sensor frame's origin is
	// identical to sensor detection frame's origin. Detections are defined in
	// the sensor detection frame which uses e.g. spherical coordinates.
	//
	// \par References:
	// - [1] DIN ISO 8855:2013-11
	//
	MountingPosition *MountingPosition `protobuf:"bytes,3,opt,name=mounting_position,json=mountingPosition,proto3" json:"mounting_position,omitempty"`
	// The origin/orientation of the sensor frame represents the current
	// mounting pose to the best knowledge of the sensor. The estimation of the
	// 6D pose given by the calibration. The uncertainty of this estimation is
	// given with the corresponding 6D root mean squared error. The estimation
	// of the current origin does not include effects due to short-time
	// dynamics, such as pitch angles from braking, but includes long-time
	// calibration values, such as pitch angles from luggage in the trunk.
	//
	MountingPositionRmse *MountingPosition `protobuf:"bytes,4,opt,name=mounting_position_rmse,json=mountingPositionRmse,proto3" json:"mounting_position_rmse,omitempty"`
	// Data Qualifier expresses to what extent the content of this event can be
	// relied on.
	//
	DataQualifier SensorDetectionHeader_DataQualifier `protobuf:"varint,5,opt,name=data_qualifier,json=dataQualifier,proto3,enum=osi3.SensorDetectionHeader_DataQualifier" json:"data_qualifier,omitempty"`
	// The current number of valid detections in the detections list.
	//
	// \note This value has to be set if the list contains invalid detections.
	//
	NumberOfValidDetections uint32 `protobuf:"varint,6,opt,name=number_of_valid_detections,json=numberOfValidDetections,proto3" json:"number_of_valid_detections,omitempty"`
	// The ID of the sensor at host vehicle's mounting_position.
	//
	// This ID can equal \c SensorData::sensor_id, if \c SensorData holds only
	// data from one sensor/sensor model.
	//
	SensorId             *Identifier `protobuf:"bytes,7,opt,name=sensor_id,json=sensorId,proto3" json:"sensor_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SensorDetectionHeader) Reset()         { *m = SensorDetectionHeader{} }
func (m *SensorDetectionHeader) String() string { return proto.CompactTextString(m) }
func (*SensorDetectionHeader) ProtoMessage()    {}
func (*SensorDetectionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{1}
}

func (m *SensorDetectionHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SensorDetectionHeader.Unmarshal(m, b)
}
func (m *SensorDetectionHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SensorDetectionHeader.Marshal(b, m, deterministic)
}
func (m *SensorDetectionHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorDetectionHeader.Merge(m, src)
}
func (m *SensorDetectionHeader) XXX_Size() int {
	return xxx_messageInfo_SensorDetectionHeader.Size(m)
}
func (m *SensorDetectionHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorDetectionHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SensorDetectionHeader proto.InternalMessageInfo

func (m *SensorDetectionHeader) GetMeasurementTime() *Timestamp {
	if m != nil {
		return m.MeasurementTime
	}
	return nil
}

func (m *SensorDetectionHeader) GetCycleCounter() uint64 {
	if m != nil {
		return m.CycleCounter
	}
	return 0
}

func (m *SensorDetectionHeader) GetMountingPosition() *MountingPosition {
	if m != nil {
		return m.MountingPosition
	}
	return nil
}

func (m *SensorDetectionHeader) GetMountingPositionRmse() *MountingPosition {
	if m != nil {
		return m.MountingPositionRmse
	}
	return nil
}

func (m *SensorDetectionHeader) GetDataQualifier() SensorDetectionHeader_DataQualifier {
	if m != nil {
		return m.DataQualifier
	}
	return SensorDetectionHeader_DATA_QUALIFIER_UNKNOWN
}

func (m *SensorDetectionHeader) GetNumberOfValidDetections() uint32 {
	if m != nil {
		return m.NumberOfValidDetections
	}
	return 0
}

func (m *SensorDetectionHeader) GetSensorId() *Identifier {
	if m != nil {
		return m.SensorId
	}
	return nil
}

//
// \brief Data from one radar sensor including a list of detections.
//
type RadarDetectionData struct {
	// Header attributes of radar detection from one radar sensor.
	//
	Header *SensorDetectionHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// List of radar detections constituting the radar detection list.
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	Detection            []*RadarDetection `protobuf:"bytes,2,rep,name=detection,proto3" json:"detection,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RadarDetectionData) Reset()         { *m = RadarDetectionData{} }
func (m *RadarDetectionData) String() string { return proto.CompactTextString(m) }
func (*RadarDetectionData) ProtoMessage()    {}
func (*RadarDetectionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{2}
}

func (m *RadarDetectionData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RadarDetectionData.Unmarshal(m, b)
}
func (m *RadarDetectionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RadarDetectionData.Marshal(b, m, deterministic)
}
func (m *RadarDetectionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadarDetectionData.Merge(m, src)
}
func (m *RadarDetectionData) XXX_Size() int {
	return xxx_messageInfo_RadarDetectionData.Size(m)
}
func (m *RadarDetectionData) XXX_DiscardUnknown() {
	xxx_messageInfo_RadarDetectionData.DiscardUnknown(m)
}

var xxx_messageInfo_RadarDetectionData proto.InternalMessageInfo

func (m *RadarDetectionData) GetHeader() *SensorDetectionHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RadarDetectionData) GetDetection() []*RadarDetection {
	if m != nil {
		return m.Detection
	}
	return nil
}

//
// \brief A radar detection.
//
type RadarDetection struct {
	// Existence probability of the detection not based on history. Value does
	// not depend on any past experience with similar detections.
	//
	// \note Use as confidence measure where a low value means less confidence
	// and a high value indicates strong confidence.
	//
	ExistenceProbability float64 `protobuf:"fixed64,1,opt,name=existence_probability,json=existenceProbability,proto3" json:"existence_probability,omitempty"`
	// ID of the detected object this detection is associated to.
	//
	// \note ID = MAX(uint64) indicates no reference to an object.
	//
	ObjectId *Identifier `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Measured position of the detection, given in spherical coordinates in the
	// sensor coordinate system.
	//
	Position *Spherical3D `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	// Root mean squared error of the measured position of the detection.
	//
	PositionRmse *Spherical3D `protobuf:"bytes,4,opt,name=position_rmse,json=positionRmse,proto3" json:"position_rmse,omitempty"`
	// Absolute radial (in direction to the sensor) velocity of the detection.
	//
	// Unit: [m/s]
	//
	RadialVelocity float64 `protobuf:"fixed64,5,opt,name=radial_velocity,json=radialVelocity,proto3" json:"radial_velocity,omitempty"`
	// Root mean squared error of the object measured radial velocity.
	//
	// Unit: [m/s]
	//
	RadialVelocityRmse float64 `protobuf:"fixed64,6,opt,name=radial_velocity_rmse,json=radialVelocityRmse,proto3" json:"radial_velocity_rmse,omitempty"`
	// The radar cross section (RCS) of the radar detection.
	//
	// Unit: [dB m^2]
	//
	Rcs float64 `protobuf:"fixed64,7,opt,name=rcs,proto3" json:"rcs,omitempty"`
	// The signal to noise ratio (SNR) of the radar detection.
	//
	// Unit: [dB]
	//
	Snr float64 `protobuf:"fixed64,8,opt,name=snr,proto3" json:"snr,omitempty"`
	// Describes the possibility whether more than one object may have led to
	// this detection.
	//
	PointTargetProbability float64 `protobuf:"fixed64,9,opt,name=point_target_probability,json=pointTargetProbability,proto3" json:"point_target_probability,omitempty"`
	// Ambiguity Information:
	// Each ambiguous measurement generates one Ambiguity ID. Ambiguity is
	// indicated by an identical ambiguity ID.
	//
	// \note Unambiguous measurements have the ambiguity ID 0.
	// \note Multiple seperate detections from e.g. a large object do not
	// on their own necessarily create any ambiguity, i.e. they do not
	// usually share an an ambiguity ID.  They can however be ambiguous
	// with other detections.
	//
	AmbiguityId *Identifier `protobuf:"bytes,10,opt,name=ambiguity_id,json=ambiguityId,proto3" json:"ambiguity_id,omitempty"`
	// Basic classification of the detection.
	//
	Classification       DetectionClassification `protobuf:"varint,11,opt,name=classification,proto3,enum=osi3.DetectionClassification" json:"classification,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *RadarDetection) Reset()         { *m = RadarDetection{} }
func (m *RadarDetection) String() string { return proto.CompactTextString(m) }
func (*RadarDetection) ProtoMessage()    {}
func (*RadarDetection) Descriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{3}
}

func (m *RadarDetection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RadarDetection.Unmarshal(m, b)
}
func (m *RadarDetection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RadarDetection.Marshal(b, m, deterministic)
}
func (m *RadarDetection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadarDetection.Merge(m, src)
}
func (m *RadarDetection) XXX_Size() int {
	return xxx_messageInfo_RadarDetection.Size(m)
}
func (m *RadarDetection) XXX_DiscardUnknown() {
	xxx_messageInfo_RadarDetection.DiscardUnknown(m)
}

var xxx_messageInfo_RadarDetection proto.InternalMessageInfo

func (m *RadarDetection) GetExistenceProbability() float64 {
	if m != nil {
		return m.ExistenceProbability
	}
	return 0
}

func (m *RadarDetection) GetObjectId() *Identifier {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

func (m *RadarDetection) GetPosition() *Spherical3D {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *RadarDetection) GetPositionRmse() *Spherical3D {
	if m != nil {
		return m.PositionRmse
	}
	return nil
}

func (m *RadarDetection) GetRadialVelocity() float64 {
	if m != nil {
		return m.RadialVelocity
	}
	return 0
}

func (m *RadarDetection) GetRadialVelocityRmse() float64 {
	if m != nil {
		return m.RadialVelocityRmse
	}
	return 0
}

func (m *RadarDetection) GetRcs() float64 {
	if m != nil {
		return m.Rcs
	}
	return 0
}

func (m *RadarDetection) GetSnr() float64 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *RadarDetection) GetPointTargetProbability() float64 {
	if m != nil {
		return m.PointTargetProbability
	}
	return 0
}

func (m *RadarDetection) GetAmbiguityId() *Identifier {
	if m != nil {
		return m.AmbiguityId
	}
	return nil
}

func (m *RadarDetection) GetClassification() DetectionClassification {
	if m != nil {
		return m.Classification
	}
	return DetectionClassification_DETECTION_CLASSIFICATION_UNKNOWN
}

//
// \brief Data from one lidar sensor including a list of detections.
//
type LidarDetectionData struct {
	// Header attributes of lidar detection from one lidar sensor.
	//
	Header *SensorDetectionHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// List of lidar detections.
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	Detection            []*LidarDetection `protobuf:"bytes,2,rep,name=detection,proto3" json:"detection,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LidarDetectionData) Reset()         { *m = LidarDetectionData{} }
func (m *LidarDetectionData) String() string { return proto.CompactTextString(m) }
func (*LidarDetectionData) ProtoMessage()    {}
func (*LidarDetectionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{4}
}

func (m *LidarDetectionData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LidarDetectionData.Unmarshal(m, b)
}
func (m *LidarDetectionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LidarDetectionData.Marshal(b, m, deterministic)
}
func (m *LidarDetectionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LidarDetectionData.Merge(m, src)
}
func (m *LidarDetectionData) XXX_Size() int {
	return xxx_messageInfo_LidarDetectionData.Size(m)
}
func (m *LidarDetectionData) XXX_DiscardUnknown() {
	xxx_messageInfo_LidarDetectionData.DiscardUnknown(m)
}

var xxx_messageInfo_LidarDetectionData proto.InternalMessageInfo

func (m *LidarDetectionData) GetHeader() *SensorDetectionHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *LidarDetectionData) GetDetection() []*LidarDetection {
	if m != nil {
		return m.Detection
	}
	return nil
}

//
// \brief A point or vertical line in a lidar point cloud.
//
type LidarDetection struct {
	// Existence probability of the detection not based on history. Value does
	// not depend on any past experience with similar detections.
	//
	// \note Used as confidence measure where a low value means less confidence
	// and a high value indicates strong confidence.
	//
	ExistenceProbability float64 `protobuf:"fixed64,1,opt,name=existence_probability,json=existenceProbability,proto3" json:"existence_probability,omitempty"`
	// ID of the detected object this detection is associated to.
	//
	// \note ID = MAX(uint64) indicates no reference to an object.
	//
	ObjectId *Identifier `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3" json:"object_id,omitempty"`
	// Measured position of the detection, given in spherical coordinates in the
	// sensor coordinate system.
	//
	Position *Spherical3D `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	// Root mean squared error of the measured position of the detection.
	//
	PositionRmse *Spherical3D `protobuf:"bytes,4,opt,name=position_rmse,json=positionRmse,proto3" json:"position_rmse,omitempty"`
	// Height value, which is required when multiple scan points are vertically
	// clustered. Only vertical clustering is allowed (z-axis).
	//
	// Unit: [m]
	//
	Height float64 `protobuf:"fixed64,5,opt,name=height,proto3" json:"height,omitempty"`
	// Root mean squared error of the object height.
	//
	// Unit: [m]
	//
	HeightRmse float64 `protobuf:"fixed64,6,opt,name=height_rmse,json=heightRmse,proto3" json:"height_rmse,omitempty"`
	// Intensity or equivalent value of the detection's echo.
	//
	// Unit: [%]
	//
	Intensity float64 `protobuf:"fixed64,7,opt,name=intensity,proto3" json:"intensity,omitempty"`
	// The free space probability in the range [0.0, 1.0] from the origin of the
	// sensor up to this detection, as given by the distance.
	//
	// Range: [0.0, 1.0]
	//
	FreeSpaceProbability float64 `protobuf:"fixed64,8,opt,name=free_space_probability,json=freeSpaceProbability,proto3" json:"free_space_probability,omitempty"`
	// Basic classification of the detection.
	//
	Classification DetectionClassification `protobuf:"varint,9,opt,name=classification,proto3,enum=osi3.DetectionClassification" json:"classification,omitempty"`
	// Lambertian reflectivity
	//
	Reflectivity         float64  `protobuf:"fixed64,10,opt,name=reflectivity,proto3" json:"reflectivity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LidarDetection) Reset()         { *m = LidarDetection{} }
func (m *LidarDetection) String() string { return proto.CompactTextString(m) }
func (*LidarDetection) ProtoMessage()    {}
func (*LidarDetection) Descriptor() ([]byte, []int) {
	return fileDescriptor_68817ea84a3552f4, []int{5}
}

func (m *LidarDetection) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LidarDetection.Unmarshal(m, b)
}
func (m *LidarDetection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LidarDetection.Marshal(b, m, deterministic)
}
func (m *LidarDetection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LidarDetection.Merge(m, src)
}
func (m *LidarDetection) XXX_Size() int {
	return xxx_messageInfo_LidarDetection.Size(m)
}
func (m *LidarDetection) XXX_DiscardUnknown() {
	xxx_messageInfo_LidarDetection.DiscardUnknown(m)
}

var xxx_messageInfo_LidarDetection proto.InternalMessageInfo

func (m *LidarDetection) GetExistenceProbability() float64 {
	if m != nil {
		return m.ExistenceProbability
	}
	return 0
}

func (m *LidarDetection) GetObjectId() *Identifier {
	if m != nil {
		return m.ObjectId
	}
	return nil
}

func (m *LidarDetection) GetPosition() *Spherical3D {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *LidarDetection) GetPositionRmse() *Spherical3D {
	if m != nil {
		return m.PositionRmse
	}
	return nil
}

func (m *LidarDetection) GetHeight() float64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *LidarDetection) GetHeightRmse() float64 {
	if m != nil {
		return m.HeightRmse
	}
	return 0
}

func (m *LidarDetection) GetIntensity() float64 {
	if m != nil {
		return m.Intensity
	}
	return 0
}

func (m *LidarDetection) GetFreeSpaceProbability() float64 {
	if m != nil {
		return m.FreeSpaceProbability
	}
	return 0
}

func (m *LidarDetection) GetClassification() DetectionClassification {
	if m != nil {
		return m.Classification
	}
	return DetectionClassification_DETECTION_CLASSIFICATION_UNKNOWN
}

func (m *LidarDetection) GetReflectivity() float64 {
	if m != nil {
		return m.Reflectivity
	}
	return 0
}

func init() {
	proto.RegisterEnum("osi3.DetectionClassification", DetectionClassification_name, DetectionClassification_value)
	proto.RegisterEnum("osi3.SensorDetectionHeader_DataQualifier", SensorDetectionHeader_DataQualifier_name, SensorDetectionHeader_DataQualifier_value)
	proto.RegisterType((*FeatureData)(nil), "osi3.FeatureData")
	proto.RegisterType((*SensorDetectionHeader)(nil), "osi3.SensorDetectionHeader")
	proto.RegisterType((*RadarDetectionData)(nil), "osi3.RadarDetectionData")
	proto.RegisterType((*RadarDetection)(nil), "osi3.RadarDetection")
	proto.RegisterType((*LidarDetectionData)(nil), "osi3.LidarDetectionData")
	proto.RegisterType((*LidarDetection)(nil), "osi3.LidarDetection")
}

func init() { proto.RegisterFile("osi_featuredata.proto", fileDescriptor_68817ea84a3552f4) }

var fileDescriptor_68817ea84a3552f4 = []byte{
	// 954 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x66, 0xec, 0x24, 0x9b, 0x94, 0x13, 0x67, 0xd2, 0x72, 0xbc, 0xa3, 0x10, 0xc0, 0x32, 0xb0,
	0x64, 0x57, 0xda, 0x68, 0x15, 0x23, 0x84, 0xd8, 0xd3, 0xc4, 0x9e, 0x28, 0x23, 0xbc, 0x76, 0xb6,
	0x3d, 0x31, 0xe2, 0x34, 0x6a, 0xcf, 0xb4, 0x93, 0x46, 0xf3, 0x63, 0xba, 0xc7, 0x11, 0x7b, 0xe0,
	0xca, 0x99, 0xd7, 0xe1, 0xc0, 0x53, 0xf0, 0x24, 0xbc, 0x01, 0xea, 0xee, 0x89, 0x33, 0x9e, 0xd8,
	0x39, 0x20, 0x4e, 0xdc, 0x7a, 0xea, 0xfb, 0xaa, 0xaa, 0xab, 0xea, 0xab, 0xb6, 0xe1, 0x30, 0x15,
	0xcc, 0x9f, 0x52, 0x92, 0xcd, 0x39, 0x0d, 0x49, 0x46, 0x4e, 0x67, 0x3c, 0xcd, 0x52, 0xb4, 0x91,
	0x0a, 0xd6, 0x39, 0x3a, 0x90, 0xe0, 0x1d, 0xe5, 0x82, 0xa5, 0x89, 0x06, 0x8e, 0x4c, 0x69, 0x0a,
	0xd2, 0x38, 0xbe, 0xb7, 0xb4, 0xff, 0x30, 0xa0, 0x76, 0xa1, 0x03, 0xf4, 0x48, 0x46, 0xd0, 0x1b,
	0x78, 0x96, 0xbb, 0x58, 0x46, 0xcb, 0x38, 0xa9, 0x9d, 0x35, 0x4f, 0x65, 0xb0, 0x53, 0x37, 0xc9,
	0x28, 0x9f, 0x92, 0x80, 0x8e, 0x35, 0x8a, 0xef, 0x69, 0xe8, 0x2d, 0xec, 0x72, 0x12, 0x12, 0xee,
	0x0b, 0x9a, 0x88, 0x94, 0x5b, 0x95, 0x56, 0xf5, 0xa4, 0x76, 0x66, 0x69, 0x37, 0x2c, 0x91, 0x1e,
	0xcd, 0x68, 0x90, 0xb1, 0x34, 0x91, 0x19, 0x70, 0x4d, 0xb1, 0x47, 0x8a, 0x2c, 0x9d, 0x23, 0x56,
	0x70, 0xae, 0x16, 0x9d, 0xfb, 0xec, 0xb1, 0xb3, 0x62, 0x6b, 0xe7, 0xf6, 0x9f, 0x9b, 0x70, 0xa8,
	0x8f, 0x0b, 0xd2, 0x25, 0x25, 0x21, 0xe5, 0xe8, 0x3b, 0x30, 0x63, 0x4a, 0xc4, 0x9c, 0xd3, 0x98,
	0x26, 0x99, 0x9f, 0xb1, 0x98, 0xe6, 0xe5, 0xec, 0xeb, 0xd0, 0x1e, 0x8b, 0xa9, 0xc8, 0x48, 0x3c,
	0xc3, 0xfb, 0x05, 0xa2, 0xb4, 0xa2, 0xcf, 0x61, 0x2f, 0xf8, 0x10, 0x44, 0xd4, 0x0f, 0xd2, 0xb9,
	0x2c, 0xda, 0xaa, 0xb4, 0x8c, 0x93, 0x0d, 0xbc, 0xab, 0x8c, 0x5d, 0x6d, 0x43, 0x5d, 0x38, 0x88,
	0xe5, 0x91, 0x25, 0x37, 0xfe, 0x2c, 0x15, 0x4c, 0xe6, 0xb6, 0xaa, 0xc5, 0x86, 0xbd, 0xcb, 0xe1,
	0xab, 0x1c, 0xc5, 0x66, 0x5c, 0xb2, 0xa0, 0x3e, 0x34, 0x1f, 0x05, 0xf1, 0x79, 0x2c, 0xa8, 0xb5,
	0xf1, 0x64, 0xa4, 0x46, 0x39, 0x12, 0x8e, 0x05, 0x45, 0x57, 0x50, 0x97, 0x12, 0xf0, 0x7f, 0x9e,
	0x93, 0x88, 0x4d, 0x19, 0xe5, 0xd6, 0x66, 0xcb, 0x38, 0xa9, 0x9f, 0xbd, 0xd4, 0x51, 0x56, 0x36,
	0xea, 0x54, 0x36, 0xf5, 0xfd, 0xbd, 0x03, 0xde, 0x0b, 0x8b, 0x9f, 0xe8, 0x2d, 0x1c, 0x25, 0xf3,
	0x78, 0x42, 0xb9, 0x9f, 0x4e, 0xfd, 0x3b, 0x12, 0xb1, 0xd0, 0x0f, 0xef, 0xfd, 0x85, 0xb5, 0xd5,
	0x32, 0x4e, 0xf6, 0xf0, 0x73, 0xcd, 0x18, 0x4e, 0xc7, 0x12, 0x5f, 0x84, 0x17, 0xe8, 0x35, 0xec,
	0xe8, 0x99, 0xfa, 0x2c, 0xb4, 0x9e, 0xa9, 0x7a, 0xcc, 0x5c, 0x4a, 0x21, 0x4d, 0x32, 0x9d, 0x70,
	0x5b, 0x53, 0xdc, 0xb0, 0xfd, 0xb7, 0x01, 0x7b, 0x4b, 0x97, 0x41, 0x47, 0xd0, 0xec, 0xd9, 0x9e,
	0xed, 0xbf, 0xbf, 0xb6, 0xfb, 0xee, 0x85, 0xeb, 0x60, 0xff, 0x7a, 0xf0, 0xfd, 0x60, 0xf8, 0xc3,
	0xc0, 0xfc, 0x08, 0x59, 0xd0, 0x28, 0x61, 0x43, 0xef, 0xd2, 0xc1, 0xa6, 0x81, 0x8e, 0xc1, 0x2a,
	0x21, 0xf6, 0xd8, 0x76, 0xfb, 0xf6, 0x79, 0xdf, 0x31, 0x2b, 0xe8, 0x0b, 0x68, 0xad, 0x43, 0x7d,
	0xec, 0xf4, 0xae, 0xbb, 0x4e, 0xcf, 0xac, 0xa2, 0x16, 0x1c, 0x97, 0x58, 0x83, 0xa1, 0x57, 0x88,
	0xb3, 0xb1, 0x22, 0xcb, 0x79, 0xdf, 0x1d, 0xf4, 0x06, 0xce, 0x68, 0x64, 0x6e, 0xa2, 0x17, 0xd0,
	0x2e, 0xa1, 0x9e, 0xf3, 0xee, 0x6a, 0x88, 0x6d, 0xfc, 0x63, 0x21, 0xca, 0x56, 0xfb, 0x57, 0x40,
	0x8f, 0xf7, 0x03, 0x75, 0x60, 0xeb, 0x56, 0x0d, 0x27, 0x57, 0xec, 0xc7, 0x4f, 0xcc, 0x0f, 0xe7,
	0x54, 0x74, 0x06, 0x3b, 0x8b, 0xd1, 0xe4, 0x1b, 0xd8, 0x58, 0xb5, 0x81, 0xf8, 0x81, 0xd6, 0xfe,
	0x7d, 0x03, 0xea, 0xcb, 0x28, 0xea, 0xc0, 0x21, 0xfd, 0x85, 0x89, 0x8c, 0x26, 0x01, 0xf5, 0x67,
	0x3c, 0x9d, 0x90, 0x09, 0x8b, 0x58, 0xf6, 0x41, 0x5d, 0xc5, 0xc0, 0x8d, 0x05, 0x78, 0xf5, 0x80,
	0xc9, 0x49, 0xa7, 0x93, 0x9f, 0x68, 0x90, 0xc9, 0x49, 0x57, 0xd6, 0x4d, 0x5a, 0x53, 0xdc, 0x10,
	0xbd, 0x86, 0xed, 0xd2, 0xc6, 0x1c, 0xe4, 0x15, 0xce, 0x6e, 0x29, 0x67, 0x01, 0x89, 0x3a, 0x21,
	0x5e, 0x50, 0xd0, 0x37, 0xb0, 0xb7, 0x6a, 0x37, 0x56, 0xf8, 0xec, 0xce, 0x8a, 0xeb, 0xf0, 0x15,
	0xec, 0x73, 0x12, 0x32, 0x12, 0xf9, 0x77, 0x34, 0x4a, 0x03, 0x59, 0xc4, 0xa6, 0x2a, 0xa2, 0xae,
	0xcd, 0xe3, 0xdc, 0x8a, 0xde, 0x40, 0xa3, 0x44, 0xd4, 0x79, 0xb6, 0x14, 0x1b, 0x2d, 0xb3, 0x55,
	0x68, 0x13, 0xaa, 0x3c, 0x10, 0x4a, 0xd4, 0x06, 0x96, 0x47, 0x69, 0x11, 0x09, 0xb7, 0xb6, 0xb5,
	0x45, 0x24, 0x1c, 0x7d, 0x0b, 0xd6, 0x2c, 0x65, 0xf2, 0xed, 0x21, 0xfc, 0x86, 0x66, 0x4b, 0xcd,
	0xdc, 0x51, 0xb4, 0xa6, 0xc2, 0x3d, 0x05, 0x17, 0xdb, 0xd9, 0x81, 0x5d, 0x12, 0x4f, 0xd8, 0xcd,
	0x5c, 0xde, 0x84, 0x85, 0x16, 0xac, 0xe9, 0x68, 0x6d, 0xc1, 0x72, 0x43, 0xe4, 0x40, 0x3d, 0x88,
	0x88, 0x10, 0x6c, 0xca, 0x02, 0xa2, 0x5a, 0x5b, 0x53, 0xcb, 0xff, 0x89, 0x76, 0x5b, 0x4c, 0xb8,
	0xbb, 0x44, 0xc2, 0x25, 0x27, 0xa9, 0xc8, 0xc7, 0x8f, 0xee, 0x7f, 0xad, 0xc8, 0xe5, 0x0c, 0x45,
	0x45, 0xfe, 0x55, 0x85, 0xfa, 0x32, 0xfa, 0x7f, 0x52, 0x64, 0x53, 0xb6, 0x91, 0xdd, 0xdc, 0x66,
	0xb9, 0x10, 0xf3, 0x2f, 0xf4, 0x19, 0xd4, 0xf4, 0xa9, 0xa8, 0x3b, 0xd0, 0x26, 0xe5, 0x78, 0x0c,
	0x3b, 0x2c, 0xc9, 0x68, 0x22, 0x64, 0xdd, 0x5a, 0x75, 0x0f, 0x06, 0xf4, 0x35, 0x34, 0xa7, 0x9c,
	0x52, 0x5f, 0xcc, 0x48, 0xa9, 0x45, 0x5a, 0x8e, 0x0d, 0x89, 0x8e, 0x24, 0x58, 0x6c, 0xd1, 0x63,
	0xc1, 0xec, 0xfc, 0x0b, 0xc1, 0xa0, 0x36, 0xec, 0x72, 0x3a, 0x8d, 0x24, 0xf7, 0x4e, 0xa6, 0x04,
	0x95, 0x72, 0xc9, 0xf6, 0xea, 0xb7, 0x0a, 0x3c, 0x5f, 0x13, 0x4f, 0x3d, 0xc8, 0x8e, 0xe7, 0x74,
	0x3d, 0x77, 0x38, 0xf0, 0xbb, 0x7d, 0x7b, 0x34, 0x72, 0x2f, 0xdc, 0xae, 0xad, 0x3e, 0x1f, 0x9e,
	0xfb, 0x36, 0x7c, 0xba, 0x96, 0x75, 0xff, 0xf0, 0x3f, 0x15, 0xc9, 0x1d, 0x8c, 0xed, 0xbe, 0xdb,
	0xcb, 0x7f, 0x00, 0xd6, 0xb1, 0xba, 0xfd, 0x6b, 0xcf, 0x73, 0xb0, 0x59, 0x45, 0x2f, 0xe1, 0xcb,
	0xf5, 0xf9, 0xc6, 0x0e, 0xee, 0x61, 0x77, 0x9c, 0xff, 0x12, 0xbc, 0x82, 0x17, 0x4f, 0x14, 0xd0,
	0x2b, 0x70, 0x37, 0xcf, 0x2b, 0x97, 0xc6, 0x64, 0x4b, 0xfd, 0xed, 0xea, 0xfc, 0x13, 0x00, 0x00,
	0xff, 0xff, 0x25, 0xbb, 0x07, 0x87, 0xba, 0x09, 0x00, 0x00,
}
