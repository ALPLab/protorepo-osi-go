// Code generated by protoc-gen-go. DO NOT EDIT.
// source: osi_lane.proto

package osi3

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Definition of available lane types.
//
type Lane_Classification_Type int32

const (
	// Lane of unknown type (must not be used in ground truth).
	//
	Lane_Classification_TYPE_UNKNOWN Lane_Classification_Type = 0
	// Any other type of lane.
	//
	Lane_Classification_TYPE_OTHER Lane_Classification_Type = 1
	// A normal lane.
	// Example: lanes with IDs 1, 2, 3, 4 and 7 of the highway_exit
	// image.
	//
	Lane_Classification_TYPE_DRIVING Lane_Classification_Type = 2
	// A road where driving is normally not permitted.
	//
	Lane_Classification_TYPE_NONDRIVING Lane_Classification_Type = 3
	// An intersection as a lane.
	//
	Lane_Classification_TYPE_INTERSECTION Lane_Classification_Type = 4
)

var Lane_Classification_Type_name = map[int32]string{
	0: "TYPE_UNKNOWN",
	1: "TYPE_OTHER",
	2: "TYPE_DRIVING",
	3: "TYPE_NONDRIVING",
	4: "TYPE_INTERSECTION",
}

var Lane_Classification_Type_value = map[string]int32{
	"TYPE_UNKNOWN":      0,
	"TYPE_OTHER":        1,
	"TYPE_DRIVING":      2,
	"TYPE_NONDRIVING":   3,
	"TYPE_INTERSECTION": 4,
}

func (x Lane_Classification_Type) String() string {
	return proto.EnumName(Lane_Classification_Type_name, int32(x))
}

func (Lane_Classification_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{0, 0, 0}
}

// The lane boundary type.
// There is no special representation for double lines, e.g. solid /
// solid or dashed / solid. In such cases, each lane will define its own
// side of the lane boundary.
//
type LaneBoundary_Classification_Type int32

const (
	// The type of lane boundary is unknown. Value must not be used in
	// ground truth.
	//
	LaneBoundary_Classification_TYPE_UNKNOWN LaneBoundary_Classification_Type = 0
	// Unspecified but known type of lane boundary.
	// Consider proposing an additional type if using TYPE_OTHER.
	//
	LaneBoundary_Classification_TYPE_OTHER LaneBoundary_Classification_Type = 1
	// An invisible lane boundary (e.g. unmarked part of a dashed line).
	//
	LaneBoundary_Classification_TYPE_NO_LINE LaneBoundary_Classification_Type = 2
	// A solid line at the lane boundary.
	//
	LaneBoundary_Classification_TYPE_SOLID_LINE LaneBoundary_Classification_Type = 3
	// A dashed line at the lane boundary.
	//
	LaneBoundary_Classification_TYPE_DASHED_LINE LaneBoundary_Classification_Type = 4
	// A lane boundary consisting of Botts' dots (multiple Botts dots).
	//
	LaneBoundary_Classification_TYPE_BOTTS_DOTS LaneBoundary_Classification_Type = 5
	// A lane boundary formed by the road's edge.
	// The road edge is the end of the (paved) road surface.
	//
	LaneBoundary_Classification_TYPE_ROAD_EDGE LaneBoundary_Classification_Type = 6
	// A lane boundary formed by a snow edge that may be on the road
	// surface.
	//
	LaneBoundary_Classification_TYPE_SNOW_EDGE LaneBoundary_Classification_Type = 7
	// A lane boundary covered by grass.
	//
	LaneBoundary_Classification_TYPE_GRASS_EDGE LaneBoundary_Classification_Type = 8
	// A lane boundary covered by gravel.
	//
	LaneBoundary_Classification_TYPE_GRAVEL_EDGE LaneBoundary_Classification_Type = 9
	// A lane boundary covered by soil.
	//
	LaneBoundary_Classification_TYPE_SOIL_EDGE LaneBoundary_Classification_Type = 10
	// A guard rail.
	//
	LaneBoundary_Classification_TYPE_GUARD_RAIL LaneBoundary_Classification_Type = 11
	// A curb.
	//
	LaneBoundary_Classification_TYPE_CURB LaneBoundary_Classification_Type = 12
	// A structure (e.g. building or tunnel wall).
	//
	LaneBoundary_Classification_TYPE_STRUCTURE LaneBoundary_Classification_Type = 13
)

var LaneBoundary_Classification_Type_name = map[int32]string{
	0:  "TYPE_UNKNOWN",
	1:  "TYPE_OTHER",
	2:  "TYPE_NO_LINE",
	3:  "TYPE_SOLID_LINE",
	4:  "TYPE_DASHED_LINE",
	5:  "TYPE_BOTTS_DOTS",
	6:  "TYPE_ROAD_EDGE",
	7:  "TYPE_SNOW_EDGE",
	8:  "TYPE_GRASS_EDGE",
	9:  "TYPE_GRAVEL_EDGE",
	10: "TYPE_SOIL_EDGE",
	11: "TYPE_GUARD_RAIL",
	12: "TYPE_CURB",
	13: "TYPE_STRUCTURE",
}

var LaneBoundary_Classification_Type_value = map[string]int32{
	"TYPE_UNKNOWN":     0,
	"TYPE_OTHER":       1,
	"TYPE_NO_LINE":     2,
	"TYPE_SOLID_LINE":  3,
	"TYPE_DASHED_LINE": 4,
	"TYPE_BOTTS_DOTS":  5,
	"TYPE_ROAD_EDGE":   6,
	"TYPE_SNOW_EDGE":   7,
	"TYPE_GRASS_EDGE":  8,
	"TYPE_GRAVEL_EDGE": 9,
	"TYPE_SOIL_EDGE":   10,
	"TYPE_GUARD_RAIL":  11,
	"TYPE_CURB":        12,
	"TYPE_STRUCTURE":   13,
}

func (x LaneBoundary_Classification_Type) String() string {
	return proto.EnumName(LaneBoundary_Classification_Type_name, int32(x))
}

func (LaneBoundary_Classification_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{1, 1, 0}
}

// The color of the lane boundary in case of a lane markings.
// Lane markings that alternate in color must be represented by
// individual \c LaneBoundary segments.
//
type LaneBoundary_Classification_Color int32

const (
	// Color of marking is unknown. Value must not be used in ground
	// truth.
	//
	LaneBoundary_Classification_COLOR_UNKNOWN LaneBoundary_Classification_Color = 0
	// Other (unspecified but known) color.
	//
	LaneBoundary_Classification_COLOR_OTHER LaneBoundary_Classification_Color = 1
	// Marking without color. Used to represent logical boundaries
	// without actual physical markings at the respective position.
	// Value may be used in ground truth only.
	//
	LaneBoundary_Classification_COLOR_NONE LaneBoundary_Classification_Color = 2
	// Marking with white color.
	//
	LaneBoundary_Classification_COLOR_WHITE LaneBoundary_Classification_Color = 3
	// Marking with yellow / orange-yellow color.
	//
	LaneBoundary_Classification_COLOR_YELLOW LaneBoundary_Classification_Color = 4
	// Marking with red color
	//
	LaneBoundary_Classification_COLOR_RED LaneBoundary_Classification_Color = 5
	// Marking with blue color.
	//
	LaneBoundary_Classification_COLOR_BLUE LaneBoundary_Classification_Color = 6
	// Marking with green color;
	//
	LaneBoundary_Classification_COLOR_GREEN LaneBoundary_Classification_Color = 7
	// Marking with violet color.
	//
	LaneBoundary_Classification_COLOR_VIOLET LaneBoundary_Classification_Color = 8
)

var LaneBoundary_Classification_Color_name = map[int32]string{
	0: "COLOR_UNKNOWN",
	1: "COLOR_OTHER",
	2: "COLOR_NONE",
	3: "COLOR_WHITE",
	4: "COLOR_YELLOW",
	5: "COLOR_RED",
	6: "COLOR_BLUE",
	7: "COLOR_GREEN",
	8: "COLOR_VIOLET",
}

var LaneBoundary_Classification_Color_value = map[string]int32{
	"COLOR_UNKNOWN": 0,
	"COLOR_OTHER":   1,
	"COLOR_NONE":    2,
	"COLOR_WHITE":   3,
	"COLOR_YELLOW":  4,
	"COLOR_RED":     5,
	"COLOR_BLUE":    6,
	"COLOR_GREEN":   7,
	"COLOR_VIOLET":  8,
}

func (x LaneBoundary_Classification_Color) String() string {
	return proto.EnumName(LaneBoundary_Classification_Color_name, int32(x))
}

func (LaneBoundary_Classification_Color) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{1, 1, 1}
}

//
// \brief A lane in the road network.
//
// A lane is part of a road and mainly characterized by its center line. It also
// knows about any adjacent lanes, antecessor and successor lanes.
// The following image will be referred to by later comments. We'll use the lane
// with ID 3 as reference if not mentioned otherwise.
//
// \image html highway_exit.png
//
// For lane a to be the antecessor of lane b, the last point of a's center line
// has to be identical to the first point of b's center line (although both
// points might lie outside the simulated region, the relationship remains). Any
// lane starts or ends at such a split/merge point. No lane can ever keep its ID
// after such a split point, i.e. lane 4 has to change its ID after lane 6
// splits off of lane 4, thus in the example it becomes a new lane with ID 7.
//
type Lane struct {
	// The ID of the lane.
	// Example: 3 (see reference picture).
	//
	// \note Note ID is global unique.
	//
	Id *Identifier `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The classification of the lane.
	//
	Classification       *Lane_Classification `protobuf:"bytes,2,opt,name=classification,proto3" json:"classification,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Lane) Reset()         { *m = Lane{} }
func (m *Lane) String() string { return proto.CompactTextString(m) }
func (*Lane) ProtoMessage()    {}
func (*Lane) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{0}
}

func (m *Lane) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Lane.Unmarshal(m, b)
}
func (m *Lane) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Lane.Marshal(b, m, deterministic)
}
func (m *Lane) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lane.Merge(m, src)
}
func (m *Lane) XXX_Size() int {
	return xxx_messageInfo_Lane.Size(m)
}
func (m *Lane) XXX_DiscardUnknown() {
	xxx_messageInfo_Lane.DiscardUnknown(m)
}

var xxx_messageInfo_Lane proto.InternalMessageInfo

func (m *Lane) GetId() *Identifier {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Lane) GetClassification() *Lane_Classification {
	if m != nil {
		return m.Classification
	}
	return nil
}

//
// \brief \c Classification of a lane.
//
type Lane_Classification struct {
	// The type of the lane.
	// Example: \c #type = \c #TYPE_DRIVING (see reference picture)
	//
	Type Lane_Classification_Type `protobuf:"varint,1,opt,name=type,proto3,enum=osi3.Lane_Classification_Type" json:"type,omitempty"`
	// Indicates that the host vehicle travels on this particular lane.
	// The host vehicle may travel on more than one lane at once. This does
	// also apply for the \c CanditateLane in the \c DetectedLane .
	//
	IsHostVehicleLane bool `protobuf:"varint,2,opt,name=is_host_vehicle_lane,json=isHostVehicleLane,proto3" json:"is_host_vehicle_lane,omitempty"`
	// The lane's center line (as a list of segments).
	//
	// The center line describes the middle of the lane.
	//
	// \image html highway_exit.png "Center lines as yellow dotted lines."
	//
	// \attention The points describing the center line might be set at
	// arbitrary distances. When the points are pairwise linearly connected,
	// the lateral distance to the real ideal line (as used by the
	// simulation environment internally) must not exceed 5cm. As shown in
	// the following image:
	//
	// \image html line_approximation_error.png "Approximation error as
	// green line."
	//
	// \note The center line is the line that a typical vehicle follows more
	// or less (depending on the situation, a little more to the left or
	// right of the center line). The intended direction of travel on the
	// lane is given by the direction defined by the sequence of points
	// forming the \c #centerline w.r.t. \c #centerline_is_driving_direction.
	//
	// \note The \c #centerline is defined only for \c #type =
	// \c #TYPE_DRIVING and one \c #lane_pairing pair.
	//
	// \note Intersections and non-driving lanes do not have a center line.
	// A vehicle must calculate this individually and depending on the
	// situation.
	//
	Centerline []*Vector3D `protobuf:"bytes,3,rep,name=centerline,proto3" json:"centerline,omitempty"`
	// Definition of the intended driving direction.
	//
	// Defined and used for driving lanes.
	// true means driving direction is according to ascending storage order
	// of center line points. false means driving direction is according to
	// descending storage order of center line points.
	//
	// \note The \c #centerline_is_driving_direction is defined for \c #type
	// = \c #TYPE_DRIVING .
	//
	CenterlineIsDrivingDirection bool `protobuf:"varint,4,opt,name=centerline_is_driving_direction,json=centerlineIsDrivingDirection,proto3" json:"centerline_is_driving_direction,omitempty"`
	// List of IDs of all lane segments that are directly adjacent to the
	// lane on the left side (w.r.t. intended driving direction). Note that
	// lengths of lane segments are not synchronized and therefore there are
	// multiple adjacent segments if there is a split/merge point in the
	// adjacent lane.
	//
	// Example: The lane ID 2 is the only left adjacent lane for lane ID 3
	// in the reference picture.
	//
	// \note The \c #left_adjacent_lane_id is undefined for \c #type =
	// \c #TYPE_INTERSECTION .
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	LeftAdjacentLaneId []*Identifier `protobuf:"bytes,5,rep,name=left_adjacent_lane_id,json=leftAdjacentLaneId,proto3" json:"left_adjacent_lane_id,omitempty"`
	// List of IDs of all lane segments that are directly adjacent to the
	// lane on the right side (w.r.t. intended driving direction). Note that
	// lengths of lane segments are not synchronized and therefore there are
	// multiple adjacent segments if there is a split/merge point in the
	// adjacent lane. Example: The lane IDs 4 and 7 are the right adjacent
	// lane segments for lane ID 3 in the reference picture due to the lane
	// split. Lane ID 6 is not a right adjacent lane to lane ID 3 as they
	// are separated by lane ID 7.
	//
	// \note The \c #right_adjacent_lane_id is undefined for \c #type =
	// \c #TYPE_INTERSECTION .
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	RightAdjacentLaneId []*Identifier `protobuf:"bytes,6,rep,name=right_adjacent_lane_id,json=rightAdjacentLaneId,proto3" json:"right_adjacent_lane_id,omitempty"`
	// The antecessor/successor lane pairings of this lane. There can be
	// multiple pairings with the same antecessor and different successor
	// lanes and vice versa. The antecessor lanes end in the same point that
	// this lane starts from. The successor lanes start in the same point
	// that this lane ends in. Example:
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	LanePairing []*Lane_Classification_LanePairing `protobuf:"bytes,7,rep,name=lane_pairing,json=lanePairing,proto3" json:"lane_pairing,omitempty"`
	// The right adjacent lane boundaries \c #right_lane_boundary_id may
	// only be shared with/as the left adjacent lane boundaries \c
	// #left_lane_boundary_id of the nearest right adjacent lane \c
	// #right_adjacent_lane_id.
	//
	// \note Empty for intersections.
	//
	// \note The \c #right_lane_boundary_id is undefined for \c #type =
	// \c #TYPE_INTERSECTION .
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	RightLaneBoundaryId []*Identifier `protobuf:"bytes,8,rep,name=right_lane_boundary_id,json=rightLaneBoundaryId,proto3" json:"right_lane_boundary_id,omitempty"`
	// The left adjacent lane boundaries \c #left_lane_boundary_id may only
	// be shared with/as the right adjacent lane boundaries \c
	// #right_lane_boundary_id of the nearest left adjacent lane \c
	// #left_adjacent_lane_id.
	//
	// \note Empty for intersections.
	//
	// \note The \c #left_lane_boundary_id is undefined for \c #type =
	// \c #TYPE_INTERSECTION .
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	LeftLaneBoundaryId []*Identifier `protobuf:"bytes,9,rep,name=left_lane_boundary_id,json=leftLaneBoundaryId,proto3" json:"left_lane_boundary_id,omitempty"`
	// The free boundaries which have no/unknown assignment to left/right.
	//
	// \note \c Lane with \c #type = \c #TYPE_INTERSECTION use only free
	// lane boundaries.
	//
	// \note OSI uses singular instead of plural for repeated field names.
	//
	FreeLaneBoundaryId []*Identifier `protobuf:"bytes,10,rep,name=free_lane_boundary_id,json=freeLaneBoundaryId,proto3" json:"free_lane_boundary_id,omitempty"`
	// The condition of the lane, e.g. influenced by weather.
	//
	RoadCondition        *Lane_Classification_RoadCondition `protobuf:"bytes,11,opt,name=road_condition,json=roadCondition,proto3" json:"road_condition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *Lane_Classification) Reset()         { *m = Lane_Classification{} }
func (m *Lane_Classification) String() string { return proto.CompactTextString(m) }
func (*Lane_Classification) ProtoMessage()    {}
func (*Lane_Classification) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{0, 0}
}

func (m *Lane_Classification) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Lane_Classification.Unmarshal(m, b)
}
func (m *Lane_Classification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Lane_Classification.Marshal(b, m, deterministic)
}
func (m *Lane_Classification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lane_Classification.Merge(m, src)
}
func (m *Lane_Classification) XXX_Size() int {
	return xxx_messageInfo_Lane_Classification.Size(m)
}
func (m *Lane_Classification) XXX_DiscardUnknown() {
	xxx_messageInfo_Lane_Classification.DiscardUnknown(m)
}

var xxx_messageInfo_Lane_Classification proto.InternalMessageInfo

func (m *Lane_Classification) GetType() Lane_Classification_Type {
	if m != nil {
		return m.Type
	}
	return Lane_Classification_TYPE_UNKNOWN
}

func (m *Lane_Classification) GetIsHostVehicleLane() bool {
	if m != nil {
		return m.IsHostVehicleLane
	}
	return false
}

func (m *Lane_Classification) GetCenterline() []*Vector3D {
	if m != nil {
		return m.Centerline
	}
	return nil
}

func (m *Lane_Classification) GetCenterlineIsDrivingDirection() bool {
	if m != nil {
		return m.CenterlineIsDrivingDirection
	}
	return false
}

func (m *Lane_Classification) GetLeftAdjacentLaneId() []*Identifier {
	if m != nil {
		return m.LeftAdjacentLaneId
	}
	return nil
}

func (m *Lane_Classification) GetRightAdjacentLaneId() []*Identifier {
	if m != nil {
		return m.RightAdjacentLaneId
	}
	return nil
}

func (m *Lane_Classification) GetLanePairing() []*Lane_Classification_LanePairing {
	if m != nil {
		return m.LanePairing
	}
	return nil
}

func (m *Lane_Classification) GetRightLaneBoundaryId() []*Identifier {
	if m != nil {
		return m.RightLaneBoundaryId
	}
	return nil
}

func (m *Lane_Classification) GetLeftLaneBoundaryId() []*Identifier {
	if m != nil {
		return m.LeftLaneBoundaryId
	}
	return nil
}

func (m *Lane_Classification) GetFreeLaneBoundaryId() []*Identifier {
	if m != nil {
		return m.FreeLaneBoundaryId
	}
	return nil
}

func (m *Lane_Classification) GetRoadCondition() *Lane_Classification_RoadCondition {
	if m != nil {
		return m.RoadCondition
	}
	return nil
}

//
// \brief The condition of the road surface.
//
type Lane_Classification_RoadCondition struct {
	// The temperature of the roads surface in Kelvin.
	//
	// Unit: [K]
	//
	SurfaceTemperature float64 `protobuf:"fixed64,1,opt,name=surface_temperature,json=surfaceTemperature,proto3" json:"surface_temperature,omitempty"`
	// The height of the water film on top of the surface in mm.
	//
	// Unit: [mm]
	//
	SurfaceWaterFilm float64 `protobuf:"fixed64,2,opt,name=surface_water_film,json=surfaceWaterFilm,proto3" json:"surface_water_film,omitempty"`
	// The temperature where the water on top of the surface would start
	// to freeze or dew in Kelvin.
	//
	// Unit: [K]
	//
	SurfaceFreezingPoint float64 `protobuf:"fixed64,3,opt,name=surface_freezing_point,json=surfaceFreezingPoint,proto3" json:"surface_freezing_point,omitempty"`
	// The percentage of ice covering the road.
	//
	// Unit: [%]
	//
	SurfaceIce float64 `protobuf:"fixed64,4,opt,name=surface_ice,json=surfaceIce,proto3" json:"surface_ice,omitempty"`
	// The coefficient representing the roughness or unevenness of the
	// road. International Roughness Index (IRI) [1] values range from 0
	// = smooth ground (equivalent to driving on a plate of glass) up to
	// > 20 mm/m (a very rough road).
	//
	// Estimated value ranges (IRI):
	//        0.0 [mm/m] absolutely perfect evenness
	// 0.3 -  1.8 [mm/m] airport runways and superhighways
	// 1.4 -  3.4 [mm/m] new pavements
	// 2.2 -  5.7 [mm/m] older pavements
	// 3.2 -  9.8 [mm/m] maintained unpaved roads
	// 4.0 - 11.0 [mm/m] damaged pavements
	// 8.0 - > 20 [mm/m] rough unpaved roads
	//
	// Speed of normal use (IRI):
	//  30 [km/h] - 20   [mm/m]
	//  50 [km/h] - 14.5 [mm/m]
	//  60 [km/h] - 10.0 [mm/m]
	//  80 [km/h] -  8.5 [mm/m]
	// 100 [km/h] -  3.4 [mm/m]
	//
	// Road conditions (IRI);
	// 15 [mm/m] erosion gulleys and deep depressions
	// 11 [mm/m] frequent shallow depressions, some deep
	//  9 [mm/m] frequent minor depressions
	//  5 [mm/m] surface imperfections
	//
	// Unit: [mm/m]
	//
	// \par References:
	// - [1] SAYERS, M.W.; KARAMIHAS, S.M. Little Book of Profiling,
	// University of Michigan Transportation Research Institute, 1998.
	//
	SurfaceRoughness float64 `protobuf:"fixed64,5,opt,name=surface_roughness,json=surfaceRoughness,proto3" json:"surface_roughness,omitempty"`
	// The surface texture or fine roughness
	//
	// Whereas the IRI-based roughness or unevenness measure only takes
	// into account road wavelengths around 0.5m - 100m, the surface
	// texture or fine roughness [2] measures only wavelengths below
	// 0.5m. It is given as the standard height deviation of fine
	// roughness
	//
	// Unit: [m]
	//
	// \par References:
	// - [1] SAYERS, M.W.; KARAMIHAS, S.M. Little Book of Profiling,
	// University of Michigan Transportation Research Institute, 1998.
	// - [2] SCHNEIDER, R.: Modellierung der Wellenausbreitung fuer
	// ein bildgebendes Kfz-Radar, Dissertation, Universitaet Karlsruhe,
	// Mai 1998.
	//
	SurfaceTexture       float64  `protobuf:"fixed64,6,opt,name=surface_texture,json=surfaceTexture,proto3" json:"surface_texture,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Lane_Classification_RoadCondition) Reset()         { *m = Lane_Classification_RoadCondition{} }
func (m *Lane_Classification_RoadCondition) String() string { return proto.CompactTextString(m) }
func (*Lane_Classification_RoadCondition) ProtoMessage()    {}
func (*Lane_Classification_RoadCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{0, 0, 0}
}

func (m *Lane_Classification_RoadCondition) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Lane_Classification_RoadCondition.Unmarshal(m, b)
}
func (m *Lane_Classification_RoadCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Lane_Classification_RoadCondition.Marshal(b, m, deterministic)
}
func (m *Lane_Classification_RoadCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lane_Classification_RoadCondition.Merge(m, src)
}
func (m *Lane_Classification_RoadCondition) XXX_Size() int {
	return xxx_messageInfo_Lane_Classification_RoadCondition.Size(m)
}
func (m *Lane_Classification_RoadCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_Lane_Classification_RoadCondition.DiscardUnknown(m)
}

var xxx_messageInfo_Lane_Classification_RoadCondition proto.InternalMessageInfo

func (m *Lane_Classification_RoadCondition) GetSurfaceTemperature() float64 {
	if m != nil {
		return m.SurfaceTemperature
	}
	return 0
}

func (m *Lane_Classification_RoadCondition) GetSurfaceWaterFilm() float64 {
	if m != nil {
		return m.SurfaceWaterFilm
	}
	return 0
}

func (m *Lane_Classification_RoadCondition) GetSurfaceFreezingPoint() float64 {
	if m != nil {
		return m.SurfaceFreezingPoint
	}
	return 0
}

func (m *Lane_Classification_RoadCondition) GetSurfaceIce() float64 {
	if m != nil {
		return m.SurfaceIce
	}
	return 0
}

func (m *Lane_Classification_RoadCondition) GetSurfaceRoughness() float64 {
	if m != nil {
		return m.SurfaceRoughness
	}
	return 0
}

func (m *Lane_Classification_RoadCondition) GetSurfaceTexture() float64 {
	if m != nil {
		return m.SurfaceTexture
	}
	return 0
}

// \brief The lane ID pairings of antecessor and successor lanes.
//
type Lane_Classification_LanePairing struct {
	// The antecessor lane ID.
	//
	AntecessorLaneId *Identifier `protobuf:"bytes,1,opt,name=antecessor_lane_id,json=antecessorLaneId,proto3" json:"antecessor_lane_id,omitempty"`
	// The successor lane ID.
	//
	SuccessorLaneId      *Identifier `protobuf:"bytes,2,opt,name=successor_lane_id,json=successorLaneId,proto3" json:"successor_lane_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Lane_Classification_LanePairing) Reset()         { *m = Lane_Classification_LanePairing{} }
func (m *Lane_Classification_LanePairing) String() string { return proto.CompactTextString(m) }
func (*Lane_Classification_LanePairing) ProtoMessage()    {}
func (*Lane_Classification_LanePairing) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{0, 0, 1}
}

func (m *Lane_Classification_LanePairing) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Lane_Classification_LanePairing.Unmarshal(m, b)
}
func (m *Lane_Classification_LanePairing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Lane_Classification_LanePairing.Marshal(b, m, deterministic)
}
func (m *Lane_Classification_LanePairing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lane_Classification_LanePairing.Merge(m, src)
}
func (m *Lane_Classification_LanePairing) XXX_Size() int {
	return xxx_messageInfo_Lane_Classification_LanePairing.Size(m)
}
func (m *Lane_Classification_LanePairing) XXX_DiscardUnknown() {
	xxx_messageInfo_Lane_Classification_LanePairing.DiscardUnknown(m)
}

var xxx_messageInfo_Lane_Classification_LanePairing proto.InternalMessageInfo

func (m *Lane_Classification_LanePairing) GetAntecessorLaneId() *Identifier {
	if m != nil {
		return m.AntecessorLaneId
	}
	return nil
}

func (m *Lane_Classification_LanePairing) GetSuccessorLaneId() *Identifier {
	if m != nil {
		return m.SuccessorLaneId
	}
	return nil
}

//
// \brief A lane boundary defining the border of a lane.
//
// The left and right lane boundary define the width of the lane. Additionally,
// free markings can be defined, e.g. at construction sites. Free markings
// across multiple lanes may be defined multiple times for all affected lanes.
//
type LaneBoundary struct {
	// The ID of the lane boundary.
	//
	Id *Identifier `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The list of individual points defining the location of the lane boundary
	// (as a list of segments).
	//
	// Since a \c BoundaryPoint is part of a sequence, only the position
	// attribute has to be set for each instance. All other values will be
	// reused from the previous \c BoundaryPoint in the sequence or set to
	// default values if there is none or it was never set.
	//
	// \note For dashed lines, one \c BoundaryPoint has to be at the start and
	// another at the end of each dashed line segment. The first
	// \c BoundaryPoint defines the beginning of the first dashed lane marking.
	// The last \c BoundaryPoint defines the end of the last dashed lane
	// marking. For example, the area between the second and third
	// \c BoundaryPoint has no lane marking, and so on.
	// \note For Botts' dots lines, one \c BoundaryPoint position has to define
	// each Botts' dot.
	//
	// \attention For \c BoundaryPoint the same rule for the approximation
	// error applies as for \c Lane::Classification::centerline.
	//
	BoundaryLine []*LaneBoundary_BoundaryPoint `protobuf:"bytes,2,rep,name=boundary_line,json=boundaryLine,proto3" json:"boundary_line,omitempty"`
	// The classification of the lane boundary.
	//
	Classification       *LaneBoundary_Classification `protobuf:"bytes,3,opt,name=classification,proto3" json:"classification,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *LaneBoundary) Reset()         { *m = LaneBoundary{} }
func (m *LaneBoundary) String() string { return proto.CompactTextString(m) }
func (*LaneBoundary) ProtoMessage()    {}
func (*LaneBoundary) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{1}
}

func (m *LaneBoundary) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LaneBoundary.Unmarshal(m, b)
}
func (m *LaneBoundary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LaneBoundary.Marshal(b, m, deterministic)
}
func (m *LaneBoundary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LaneBoundary.Merge(m, src)
}
func (m *LaneBoundary) XXX_Size() int {
	return xxx_messageInfo_LaneBoundary.Size(m)
}
func (m *LaneBoundary) XXX_DiscardUnknown() {
	xxx_messageInfo_LaneBoundary.DiscardUnknown(m)
}

var xxx_messageInfo_LaneBoundary proto.InternalMessageInfo

func (m *LaneBoundary) GetId() *Identifier {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *LaneBoundary) GetBoundaryLine() []*LaneBoundary_BoundaryPoint {
	if m != nil {
		return m.BoundaryLine
	}
	return nil
}

func (m *LaneBoundary) GetClassification() *LaneBoundary_Classification {
	if m != nil {
		return m.Classification
	}
	return nil
}

//
// \brief A single point of a lane boundary.
//
type LaneBoundary_BoundaryPoint struct {
	// The position of the \c BoundaryPoint.
	//
	Position *Vector3D `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	// The overall width of the lane boundary at the position of the
	// \c BoundaryPoint .
	// Used for lines forming lane markings.
	//
	// \note Field need not be set if it is defined previous.
	// See \c LaneBoundary.
	//
	Width float64 `protobuf:"fixed64,2,opt,name=width,proto3" json:"width,omitempty"`
	// The overall height of the lane boundary at the position of the
	// \c BoundaryPoint .
	// Used for guard rails, curbstone, or similar.
	//
	// \note Field need not be set if it is previously defined.
	// See \c LaneBoundary .
	//
	Height               float64  `protobuf:"fixed64,3,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LaneBoundary_BoundaryPoint) Reset()         { *m = LaneBoundary_BoundaryPoint{} }
func (m *LaneBoundary_BoundaryPoint) String() string { return proto.CompactTextString(m) }
func (*LaneBoundary_BoundaryPoint) ProtoMessage()    {}
func (*LaneBoundary_BoundaryPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{1, 0}
}

func (m *LaneBoundary_BoundaryPoint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LaneBoundary_BoundaryPoint.Unmarshal(m, b)
}
func (m *LaneBoundary_BoundaryPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LaneBoundary_BoundaryPoint.Marshal(b, m, deterministic)
}
func (m *LaneBoundary_BoundaryPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LaneBoundary_BoundaryPoint.Merge(m, src)
}
func (m *LaneBoundary_BoundaryPoint) XXX_Size() int {
	return xxx_messageInfo_LaneBoundary_BoundaryPoint.Size(m)
}
func (m *LaneBoundary_BoundaryPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_LaneBoundary_BoundaryPoint.DiscardUnknown(m)
}

var xxx_messageInfo_LaneBoundary_BoundaryPoint proto.InternalMessageInfo

func (m *LaneBoundary_BoundaryPoint) GetPosition() *Vector3D {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *LaneBoundary_BoundaryPoint) GetWidth() float64 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *LaneBoundary_BoundaryPoint) GetHeight() float64 {
	if m != nil {
		return m.Height
	}
	return 0
}

//
// \brief \c Classification data of a lane boundary.
//
type LaneBoundary_Classification struct {
	// The type of the lane boundary.
	//
	Type LaneBoundary_Classification_Type `protobuf:"varint,1,opt,name=type,proto3,enum=osi3.LaneBoundary_Classification_Type" json:"type,omitempty"`
	// The color of the lane boundary in case of lane markings.
	//
	Color LaneBoundary_Classification_Color `protobuf:"varint,2,opt,name=color,proto3,enum=osi3.LaneBoundary_Classification_Color" json:"color,omitempty"`
	// The ids of \c StationaryObject which limit the corresponding lane.
	// This field must be set if the \c #type is set to
	// \c #TYPE_STRUCTURE
	//
	LimitingStructureId  []*Identifier `protobuf:"bytes,3,rep,name=limiting_structure_id,json=limitingStructureId,proto3" json:"limiting_structure_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LaneBoundary_Classification) Reset()         { *m = LaneBoundary_Classification{} }
func (m *LaneBoundary_Classification) String() string { return proto.CompactTextString(m) }
func (*LaneBoundary_Classification) ProtoMessage()    {}
func (*LaneBoundary_Classification) Descriptor() ([]byte, []int) {
	return fileDescriptor_d8e87d6f8ce7ef78, []int{1, 1}
}

func (m *LaneBoundary_Classification) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LaneBoundary_Classification.Unmarshal(m, b)
}
func (m *LaneBoundary_Classification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LaneBoundary_Classification.Marshal(b, m, deterministic)
}
func (m *LaneBoundary_Classification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LaneBoundary_Classification.Merge(m, src)
}
func (m *LaneBoundary_Classification) XXX_Size() int {
	return xxx_messageInfo_LaneBoundary_Classification.Size(m)
}
func (m *LaneBoundary_Classification) XXX_DiscardUnknown() {
	xxx_messageInfo_LaneBoundary_Classification.DiscardUnknown(m)
}

var xxx_messageInfo_LaneBoundary_Classification proto.InternalMessageInfo

func (m *LaneBoundary_Classification) GetType() LaneBoundary_Classification_Type {
	if m != nil {
		return m.Type
	}
	return LaneBoundary_Classification_TYPE_UNKNOWN
}

func (m *LaneBoundary_Classification) GetColor() LaneBoundary_Classification_Color {
	if m != nil {
		return m.Color
	}
	return LaneBoundary_Classification_COLOR_UNKNOWN
}

func (m *LaneBoundary_Classification) GetLimitingStructureId() []*Identifier {
	if m != nil {
		return m.LimitingStructureId
	}
	return nil
}

func init() {
	proto.RegisterEnum("osi3.Lane_Classification_Type", Lane_Classification_Type_name, Lane_Classification_Type_value)
	proto.RegisterEnum("osi3.LaneBoundary_Classification_Type", LaneBoundary_Classification_Type_name, LaneBoundary_Classification_Type_value)
	proto.RegisterEnum("osi3.LaneBoundary_Classification_Color", LaneBoundary_Classification_Color_name, LaneBoundary_Classification_Color_value)
	proto.RegisterType((*Lane)(nil), "osi3.Lane")
	proto.RegisterType((*Lane_Classification)(nil), "osi3.Lane.Classification")
	proto.RegisterType((*Lane_Classification_RoadCondition)(nil), "osi3.Lane.Classification.RoadCondition")
	proto.RegisterType((*Lane_Classification_LanePairing)(nil), "osi3.Lane.Classification.LanePairing")
	proto.RegisterType((*LaneBoundary)(nil), "osi3.LaneBoundary")
	proto.RegisterType((*LaneBoundary_BoundaryPoint)(nil), "osi3.LaneBoundary.BoundaryPoint")
	proto.RegisterType((*LaneBoundary_Classification)(nil), "osi3.LaneBoundary.Classification")
}

func init() { proto.RegisterFile("osi_lane.proto", fileDescriptor_d8e87d6f8ce7ef78) }

var fileDescriptor_d8e87d6f8ce7ef78 = []byte{
	// 1019 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x26, 0x7f, 0xfd, 0x39, 0x49, 0xdc, 0xe9, 0x6c, 0x5b, 0x85, 0x0a, 0xb1, 0xa5, 0x12, 0xec,
	0x0a, 0x50, 0x56, 0x6a, 0xb9, 0x42, 0x80, 0x94, 0x26, 0xde, 0xc6, 0xc2, 0xb2, 0xab, 0x89, 0xd3,
	0x6a, 0xaf, 0x2c, 0xaf, 0x3d, 0x69, 0x06, 0x25, 0x9e, 0x68, 0xec, 0xee, 0x52, 0x5e, 0x81, 0x1b,
	0x6e, 0x11, 0x37, 0x3c, 0x0a, 0x2f, 0xc3, 0x33, 0x70, 0x8b, 0x66, 0xc6, 0x3f, 0xf9, 0xd9, 0xec,
	0xc2, 0x5d, 0xe6, 0x3b, 0xdf, 0xf9, 0xe6, 0x9c, 0xe3, 0xcf, 0xc7, 0x01, 0x83, 0x27, 0xcc, 0x9f,
	0x05, 0x31, 0xed, 0x2e, 0x04, 0x4f, 0x39, 0xae, 0xf3, 0x84, 0x5d, 0x9e, 0x22, 0x89, 0x86, 0x7c,
	0x3e, 0xe7, 0xb1, 0xc6, 0xcf, 0xff, 0x06, 0xa8, 0xdb, 0x41, 0x4c, 0xf1, 0x19, 0x54, 0x59, 0xd4,
	0xa9, 0x9c, 0x55, 0x9e, 0x37, 0x2f, 0x50, 0x57, 0xb2, 0xbb, 0x56, 0x44, 0xe3, 0x94, 0x4d, 0x18,
	0x15, 0xa4, 0xca, 0x22, 0xdc, 0x03, 0x23, 0x9c, 0x05, 0x49, 0xc2, 0x26, 0x2c, 0x0c, 0x52, 0xc6,
	0xe3, 0x4e, 0x55, 0xb1, 0x3f, 0xd6, 0x6c, 0xa9, 0xd2, 0xed, 0xaf, 0x10, 0xc8, 0x5a, 0xc2, 0xe9,
	0x3f, 0xfb, 0x60, 0xac, 0x52, 0xf0, 0x05, 0xd4, 0xd3, 0xc7, 0x05, 0x55, 0x37, 0x1b, 0x17, 0x9f,
	0x6e, 0xd5, 0xea, 0x7a, 0x8f, 0x0b, 0x4a, 0x14, 0x17, 0xbf, 0x80, 0x23, 0x96, 0xf8, 0x53, 0x9e,
	0xa4, 0xfe, 0x1b, 0x3a, 0x65, 0xe1, 0x8c, 0xaa, 0x56, 0x55, 0x3d, 0x7b, 0xe4, 0x90, 0x25, 0x43,
	0x9e, 0xa4, 0xb7, 0x3a, 0xa2, 0x9a, 0xeb, 0x02, 0x84, 0x34, 0x4e, 0xa9, 0x98, 0xb1, 0x98, 0x76,
	0x6a, 0x67, 0xb5, 0xe7, 0xcd, 0x0b, 0x43, 0x5f, 0x75, 0x4b, 0xc3, 0x94, 0x8b, 0xcb, 0x88, 0x2c,
	0x31, 0xb0, 0x09, 0x4f, 0xcb, 0x93, 0xcf, 0x12, 0x3f, 0x12, 0xec, 0x0d, 0x8b, 0xef, 0xfd, 0x88,
	0x09, 0x1a, 0xaa, 0xde, 0xeb, 0xea, 0xae, 0x4f, 0x4a, 0x9a, 0x95, 0x0c, 0x34, 0x69, 0x90, 0x73,
	0x70, 0x1f, 0x8e, 0x67, 0x74, 0x92, 0xfa, 0x41, 0xf4, 0x53, 0x20, 0x89, 0xaa, 0x4a, 0x9f, 0x45,
	0x9d, 0x86, 0xaa, 0x60, 0x73, 0xcc, 0x58, 0xd2, 0x7b, 0x19, 0x5b, 0x56, 0x6e, 0x45, 0xd8, 0x84,
	0x13, 0xc1, 0xee, 0xa7, 0xef, 0x50, 0xd9, 0xd9, 0xa2, 0xf2, 0x44, 0xf1, 0xd7, 0x64, 0x86, 0xd0,
	0x52, 0x79, 0x8b, 0x80, 0x09, 0x16, 0xdf, 0x77, 0x76, 0x55, 0xf2, 0xe7, 0xdb, 0xe7, 0x2d, 0xb1,
	0x1b, 0x4d, 0x26, 0xcd, 0x59, 0x79, 0x28, 0x0b, 0x52, 0x7a, 0xaf, 0xf9, 0x43, 0x1c, 0x05, 0xe2,
	0x51, 0x16, 0xb4, 0xf7, 0xde, 0x82, 0xa4, 0xe0, 0x55, 0xc6, 0xb6, 0xa2, 0x62, 0x38, 0x1b, 0x2a,
	0xfb, 0xef, 0x1b, 0xce, 0xa6, 0xc8, 0x44, 0x50, 0xba, 0x29, 0x02, 0xdb, 0x44, 0x24, 0x7d, 0x4d,
	0xc4, 0x01, 0x43, 0xf0, 0x20, 0xf2, 0x43, 0x1e, 0x47, 0x4c, 0x3d, 0xdc, 0xa6, 0x32, 0xf6, 0xb3,
	0xed, 0xc3, 0x21, 0x3c, 0x88, 0xfa, 0x39, 0x9d, 0xb4, 0xc5, 0xf2, 0xf1, 0xf4, 0x8f, 0x2a, 0xb4,
	0x57, 0x08, 0xf8, 0x05, 0x3c, 0x49, 0x1e, 0xc4, 0x24, 0x08, 0xa9, 0x9f, 0xd2, 0xf9, 0x82, 0x8a,
	0x20, 0x7d, 0x10, 0xda, 0xf3, 0x15, 0x82, 0xb3, 0x90, 0x57, 0x46, 0xf0, 0xd7, 0x90, 0xa3, 0xfe,
	0xdb, 0x20, 0xa5, 0xc2, 0x9f, 0xb0, 0xd9, 0x5c, 0xf9, 0xbb, 0x42, 0x50, 0x16, 0xb9, 0x93, 0x81,
	0x97, 0x6c, 0x36, 0xc7, 0xdf, 0xc0, 0x49, 0xce, 0x96, 0xed, 0xfd, 0x22, 0x9d, 0xba, 0xe0, 0x2c,
	0x4e, 0x3b, 0x35, 0x95, 0x71, 0x94, 0x45, 0x5f, 0x66, 0xc1, 0x1b, 0x19, 0xc3, 0x4f, 0xa1, 0x99,
	0x67, 0xb1, 0x90, 0x2a, 0x43, 0x57, 0x08, 0x64, 0x90, 0x15, 0x52, 0xfc, 0x15, 0x1c, 0xe6, 0x04,
	0xc1, 0x1f, 0xee, 0xa7, 0x31, 0x4d, 0x92, 0x4e, 0x63, 0xa5, 0x06, 0x92, 0xe3, 0xf8, 0x19, 0x1c,
	0x94, 0x2d, 0xfe, 0xac, 0xda, 0xdb, 0x51, 0x54, 0xa3, 0x68, 0x4f, 0xa1, 0xa7, 0xbf, 0x56, 0xa0,
	0xb9, 0xe4, 0x2d, 0xfc, 0x03, 0xe0, 0x20, 0x4e, 0x69, 0x48, 0x93, 0x84, 0x8b, 0xc2, 0xdb, 0xdb,
	0x16, 0x11, 0x2a, 0xb9, 0x99, 0xb1, 0xbf, 0x93, 0x55, 0x86, 0x6b, 0xe9, 0xd5, 0x2d, 0xe9, 0x07,
	0x05, 0x55, 0x67, 0x9f, 0x4f, 0xa0, 0x2e, 0x17, 0x0b, 0x46, 0xd0, 0xf2, 0x5e, 0xdd, 0x98, 0xfe,
	0xd8, 0xf9, 0xd1, 0x71, 0xef, 0x1c, 0xf4, 0x11, 0x36, 0x00, 0x14, 0xe2, 0x7a, 0x43, 0x93, 0xa0,
	0x4a, 0xc1, 0x18, 0x10, 0xeb, 0xd6, 0x72, 0xae, 0x51, 0x15, 0x3f, 0x81, 0x03, 0x85, 0x38, 0xae,
	0x93, 0x83, 0x35, 0x7c, 0x0c, 0x87, 0x0a, 0xb4, 0x1c, 0xcf, 0x24, 0x23, 0xb3, 0xef, 0x59, 0xae,
	0x83, 0xea, 0xe7, 0x7f, 0xed, 0x42, 0x6b, 0xd9, 0x76, 0xff, 0x61, 0xdf, 0x9a, 0xd0, 0x2e, 0x1c,
	0xad, 0xf6, 0x56, 0x55, 0x79, 0xfa, 0xac, 0x74, 0x65, 0x2e, 0xd6, 0xcd, 0x7f, 0xa8, 0x07, 0x4b,
	0x5a, 0x79, 0x9a, 0x2d, 0x77, 0x99, 0xb5, 0xb1, 0xb6, 0x6b, 0xea, 0xd2, 0xcf, 0xde, 0xa1, 0xf3,
	0x81, 0xf5, 0xcd, 0xa0, 0xbd, 0x72, 0x13, 0xfe, 0x12, 0xf6, 0x16, 0x3c, 0xd1, 0xef, 0x8c, 0x6e,
	0x65, 0x7d, 0xab, 0x16, 0x71, 0x7c, 0x04, 0x8d, 0xb7, 0x2c, 0x4a, 0xa7, 0x99, 0x8b, 0xf5, 0x01,
	0x9f, 0xc0, 0xce, 0x94, 0xca, 0xed, 0x90, 0x59, 0x35, 0x3b, 0x9d, 0xfe, 0xd6, 0xd8, 0xf8, 0x52,
	0x7c, 0xbb, 0xf2, 0xa5, 0xf8, 0xe2, 0x83, 0xe5, 0x2f, 0x7f, 0x31, 0xbe, 0x87, 0x46, 0xc8, 0x67,
	0x5c, 0xa8, 0xcb, 0x8d, 0xe5, 0x37, 0x7b, 0x5b, 0x72, 0x5f, 0xd2, 0x89, 0xce, 0xc2, 0x03, 0x38,
	0x9e, 0xb1, 0x39, 0x4b, 0xe5, 0x8b, 0x95, 0xa4, 0xe2, 0x21, 0x94, 0x4e, 0x96, 0x3e, 0xab, 0x6d,
	0xdb, 0x78, 0x39, 0x7d, 0x94, 0xb3, 0xad, 0xe8, 0xfc, 0xf7, 0xea, 0xff, 0x36, 0x9b, 0xe3, 0xfa,
	0xb6, 0xe5, 0x98, 0x4b, 0x66, 0x1b, 0xb9, 0xb6, 0x35, 0xd0, 0x60, 0x0d, 0x1f, 0x01, 0xd2, 0x9e,
	0xec, 0x8d, 0x86, 0x66, 0x86, 0xd6, 0x0b, 0xea, 0x95, 0xeb, 0x79, 0x23, 0x7f, 0xe0, 0x7a, 0x23,
	0xd4, 0xc0, 0x18, 0x0c, 0x05, 0x12, 0xb7, 0x37, 0xf0, 0xcd, 0xc1, 0xb5, 0x89, 0x76, 0x0a, 0x6c,
	0xe4, 0xb8, 0x77, 0x1a, 0xdb, 0x2d, 0x92, 0xaf, 0x49, 0x6f, 0x34, 0xd2, 0xe0, 0x5e, 0x71, 0xcf,
	0x35, 0xe9, 0xdd, 0x9a, 0xb6, 0x46, 0xf7, 0xcb, 0x74, 0xd7, 0xca, 0x30, 0x28, 0xd3, 0xc7, 0x3d,
	0x32, 0xf0, 0x49, 0xcf, 0xb2, 0x51, 0x13, 0xb7, 0x61, 0x5f, 0x81, 0xfd, 0x31, 0xb9, 0x42, 0xad,
	0x32, 0xcf, 0x23, 0xe3, 0xbe, 0x37, 0x26, 0x26, 0x6a, 0x9f, 0xff, 0x59, 0x81, 0x86, 0x1a, 0x39,
	0x3e, 0x84, 0x76, 0xdf, 0xb5, 0x5d, 0xb2, 0x34, 0x9d, 0x03, 0x68, 0x6a, 0x28, 0x1f, 0x8f, 0x01,
	0xa0, 0x01, 0xc7, 0x55, 0xc3, 0x29, 0x08, 0x77, 0x43, 0xcb, 0x93, 0x83, 0x41, 0xd0, 0xd2, 0xc0,
	0x2b, 0xd3, 0xb6, 0xdd, 0x3b, 0x54, 0x97, 0x35, 0x68, 0x84, 0x98, 0x03, 0xd4, 0x28, 0x15, 0xae,
	0xec, 0xb1, 0x1c, 0x45, 0xa1, 0x70, 0x4d, 0x4c, 0xd3, 0x41, 0xbb, 0xa5, 0xc2, 0xad, 0xe5, 0xda,
	0xa6, 0x87, 0xf6, 0xae, 0xaa, 0xc3, 0xca, 0xeb, 0x1d, 0xf5, 0xaf, 0xe9, 0xf2, 0xdf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xef, 0xd8, 0x2d, 0x11, 0x5f, 0x09, 0x00, 0x00,
}
